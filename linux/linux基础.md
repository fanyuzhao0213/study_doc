## linux基础

[TOC]



### 1.gcc

#### 1.1 gcc 工作流程

GCC 编译器对程序的编译下图所示，分为 4 个阶段：预处理（预编译）、编译和优化、汇编和链接。GCC 的编译器可以将这 4 个步骤合并成一个。 先介绍一个每个步骤都分别做了写什么事儿:

- 预处理：在这个阶段主要做了三件事: 展开头文件 、宏替换 、去掉注释行

  这个阶段需要 GCC 调用预处理器来完成，最终得到的还是源文件，文本格式

- 编译：这个阶段需要 GCC 调用编译器对文件进行编译，最终得到一个汇编文件

- 汇编：这个阶段需要 GCC 调用汇编器对文件进行汇编，最终得到一个二进制文件


- 链接：这个阶段需要 GCC 调用链接器对程序需要调用的库进行链接，最终得到一个可执行的二进制文件


比如之下说明:

文件后缀名			说明								gcc

​	.c				源文件								无
​	.i			预处理后的 C 文件							-E
​	.s			编译之后得到的汇编语言的源文件			-S
​	.o			汇编后得到的二进制文件					-c

- **在 Linux 下使用 GCC 编译器编译单个文件十分简单，直接使用 gcc 命令后面加上要编译的 C 语言的源文件，GCC 会自动生成文件名为 a.out 的可执行文件（也可以通过参数 -o 指定生成的文件名），也就是通过一个简单的命令上边提到的 4 个步骤就全部执行完毕了。**

#### 1.2 gcc 常用参数

![1658801971661](C:\Users\Tokin_hardware\AppData\Roaming\Typora\typora-user-images\1658801971661.png)



#### 1.3 指定生成的文件名 (-o)

该参数用于指定原文件通过 gcc 处理之后生成的新文件的名字，有两种写法，原文件可以写在参数 -o 前边后缀写在后边。

参数 -o的用法 , 原材料 test.c 最终生成的文件名为 app

- test.c 写在 -o 之前

- $ gcc test.c -o app



- test.c 写在 -o 之后

$ gcc -o app test.c

#### 1.4  搜索头文件 (-I)



如果在程序中包含了一些头文件，但是包含的一些头文件在程序预处理的时候因为找不到无法被展开，导致程序编译失败，这时候我们可以在 gcc 命令中添加 -I 参数重新指定要引用的头文件路径，保证编译顺利完成。



通过编译得到的错误信息可以知道，源文件中包含的头文件无法被找到。通过提供的目录结构可以得知头文件 head.h 在 include 目录中，因此可以在编译的时候重新指定头文件位置，具体操作如下：

可以在编译的时候重新指定头文件位置 -I 头文件目录

- $ gcc *.c -o calc -I ./include

#### 1.5 gcc 与 g++

**1. 在代码编译阶段（第二个阶段）:**

- 后缀为 .c 的，gcc 把它当作是 C 程序，而 g++ 当作是 C++ 程序

- 后缀为.cpp 的，两者都会认为是 C++ 程序，C++ 的语法规则更加严谨一些

- g++ 会调用 gcc，对于 C++ 代码，两者是等价的，也就是说 gcc 和 g++ 都可以编译 C/C++ 代码

**2. 在链接阶段（最后一个阶段）:**

- gcc 和 g++ 都可以自动链接到标准 C 库
- g++ 可以自动链接到标准 C++ 库，gcc 如果要链接到标准 C++ 库需要加参数 -lstdc++

**3. 关于 __cplusplus 宏的定义**

- g++ 会自动定义__cplusplus 宏，但是这个不影响它去编译 C 程序


- gcc 需要根据文件后缀判断是否需要定义 __cplusplus 宏 （规则参考第一条）


综上所述：

- **不管是 gcc 还是 g++ 都可以编译 C 程序，编译程序的规则和参数都相同**
- **g++ 可以直接编译 C++ 程序， gcc 编译 C++ 程序需要添加额外参数 -lstdc++**
- **不管是 gcc 还是 g++ 都可以定义 __cplusplus 宏**

eg:

**编译 c 程序**

$ gcc test.c -o test					# 使用gcc
$ g++ test.c -o test					# 使用g++

**编译 c++ 程序**

$ g++ test.cpp -o test             			 # 使用g++
$ gcc test.cpp -lstdc++ -o test    		 # 使用gcc

### 2. Linux 静态库和动态库

#### 2.1 静态库

在 Linux 中静态库由程序 ar 生成，现在静态库已经不像之前那么普遍了，这主要是由于程序都在使用动态库。关于静态库的命名规则如下:

在 Linux 中静态库以 lib 作为前缀，以.a 作为后缀，中间是库的名字自己指定即可，即: libxxx.a
在 Windows 中静态库一般以 lib 作为前缀，以 lib 作为后缀，中间是库的名字需要自己指定，即: libxxx.lib

#### 2.2 生成静态链接库

生成静态库，需要先对源文件进行汇编操作 (使用参数 -c) 得到二进制格式的目标文件 (.o 格式), 然后在通过 ar 工具将目标文件打包就可以得到静态库文件了 (libxxx.a)。

使用 **ar** 工具创建静态库的时候需要三个参数:

- 参数c：创建一个库，不管库是否存在，都将创建。


- 参数s：创建目标文件索引，这在创建较大的库时能加快时间。

- 参数r：在库中插入模块 (替换)。默认新的成员添加在库的结尾处，如果模块名已经在库中存在，则替换同名的模块。

**生成静态链接库的具体步骤如下:**

**1. 需要将源文件进行汇编，得到 .o 文件，需要使用参数 -c**

执行如下操作, 默认生成二进制的 .o 文件

-c 参数位置没有要求

$ gcc 源文件(*.c) -c	

**2. 将得到的 .o 进行打包，得到静态库**
$ ar rcs 静态库的名字(libxxx.a) 原材料(*.o)

**3. 发布静态库**

提供头文件 **.h

提供制作出来的静态库 libxxx.a

#### 2.3 静态库的使用

当我们得到了一个可用的静态库之后，需要将其放到一个目录中，然后根据得到的头文件编写测试代码，对静态库中的函数进行调用。

1. 首先拿到了发布的静态库
  `head.h` 和 `libcalc.a`
2. 将静态库, 头文件, 测试程序放到一个目录中准备进行测试

.
├── head.h          # 函数声明
├── libcalc.a       # 函数定义（二进制格式）
└── main.c          # 函数测试

编译测试程序，得到可执行文件。

**编译的时候指定库信息**

- ​	-L: 指定库所在的目录(相对或者绝对路径)

- ​	-l: 指定库的名字, 掐头(lib)去尾(.a) ==> calc

- -L -l, 参数和参数值之间可以有空格, 也可以没有  -L./ -lcalc


最终如下所示：**gcc main.c -o app -L ./ -l calc**

#### 2.4 动态库

动态链接库是程序运行时加载的库，当动态链接库正确部署之后，运行的多个程序可以使用同一个加载到内存中的动态库，因此在 Linux 中动态链接库也可称之为共享库。

动态链接库是目标文件的集合，目标文件在动态链接库中的组织方式是按照特殊方式形成的。库中函数和变量的地址使用的是相对地址（静态库中使用的是绝对地址），其真实地址是在应用程序加载动态库时形成的。

关于动态库的命名规则如下:

在 Linux 中动态库以 lib 作为前缀，以.so 作为后缀，中间是库的名字自己指定即可，即: libxxx.so
在 Windows 中动态库一般以 lib 作为前缀，以 dll 作为后缀，中间是库的名字需要自己指定，即: libxxx.dll

#### 2.5 生成动态链接库

生成动态链接库是直接使用 gcc 命令并且需要添加 -fPIC（-fpic） 以及 -shared 参数。

- -fPIC 或 -fpic 参数的作用是使得 gcc 生成的代码是与位置无关的，也就是使用相对位置。
- -shared参数的作用是告诉编译器生成一个动态链接库。

生成动态链接库的具体步骤如下:

**1.将源文件进行汇编操作，需要使用参数 -c, 还需要添加额外参数 -fpic /-fPIC**

得到若干个 .o文件

- gcc 源文件(*.c) -c -fpic


**2.将得到的.o 文件打包成动态库，还是使用 gcc, 使用参数 -shared 指定生成动态库 (位置没有要求)**

gcc -shared 与位置无关的目标文件(*.o) -o 动态库(libxxx.so)



**3.发布动态库和头文件**

   	1. 提供头文件: xxx.h
   	2. 提供动态库: libxxx.so

#### 2.6  解决动态库无法加载问题

##### 2.6.1 库的工作原理

**1. 静态库如何被加载**

- 在程序编译的最后一个阶段也就是链接阶段，提供的静态库会被打包到可执行程序中。当可执行程序被执行，静态库中的代码也会一并被加载到内存中，因此不会出现静态库找不到无法被加载的问题。


**2.动态库如何被加载**

在程序编译的最后一个阶段也就是链接阶段：
- 在 gcc 命令中虽然指定了库路径 (使用参数 -L ), 但是这个路径并没有记录到可执行程序中，只是检查了这个路径下的库文件是否存在。
- 同样对应的动态库文件也没有被打包到可执行程序中，只是在可执行程序中记录了库的名字。

可执行程序被执行起来之后:
- 程序执行的时候会先检测需要的动态库是否可以被加载，加载不到就会提示上边的错误信息
- 当动态库中的函数在程序中被调用了, 这个时候动态库才加载到内存，如果不被调用就不加载
- 动态库的检测和内存加载操作都是由动态链接器来完成的

##### 2.6.2 动态链接器

动态链接器是一个独立于应用程序的进程，属于操作系统，当用户的程序需要加载动态库的时候动态连接器就开始工作了，很显然动态连接器根本就不知道用户通过 gcc 编译程序的时候通过参数 -L 指定的路径。

那么动态链接器是如何搜索某一个动态库的呢，在它内部有一个默认的搜索顺序，按照优先级从高到低的顺序分别是：

- 可执行文件内部的 DT_RPATH 段


- 系统的环境变量 LD_LIBRARY_PATH


- 系统动态库的缓存文件 /etc/ld.so.cache


- 存储动态库 / 静态库的系统目录 /lib/, /usr/lib 等

按照以上四个顺序，依次搜索，找到之后结束遍历，最终还是没找到，动态连接器就会提示动态库找不到的错误信息。

##### 2.6.3 解决方案

可执行程序生成之后，根据动态链接器的搜索路径，我们可以提供三种解决方案，我们只需要将动态库的路径放到对应的环境变量或者系统配置文件中，同样也可以将动态库拷贝到系统库目录（或者是将动态库的软链接文件放到这些系统库目录中）

- **方案 1: 将库路径添加到环境变量 LD_LIBRARY_PATH 中**

**1. 找到相关的配置文件**

用户级别: ~/.bashrc —> 设置对当前用户有效
系统级别: /etc/profile —> 设置对所有用户有效

**2. 使用 vim 打开配置文件，在文件最后添加这样一句话**

export LIBRARY_PATH=$LIBRARY_PATH:动态库的绝对路径（自己当前动态库的路径）

**3. 让修改的配置文件生效**

修改了用户级别的配置文件，关闭当前终端，打开一个新的终端配置就生效了

修改了系统级别的配置文件，注销或关闭系统，再开机配置就生效了

不想执行上边的操作，可以执行一个命令让配置重新被加载

**$ source ~/.bashrc          (. ~/.bashrc)**
**$ source /etc/profile       (. /etc/profile)**

修改的是哪一个就执行对应的那个命令

- **方案 2: 更新 /etc/ld.so.cache 文件**

**1.找到动态库所在的绝对路径（不包括库的名字）比如：/home/robin/Library/**

**2.使用 vim 修改 /etc/ld.so.conf 这个文件，将上边的路径添加到文件中 (独自占一行)**

**3.更新 /etc/ld.so.conf 中的数据到 /etc/ld.so.cache 中**

sudo ldconfig   必须使用管理员权限执行这个命令

**方案 3: 拷贝动态库文件到系统库目录 /lib/ 或者 /usr/lib 中 (或者将库的软链接文件放进去)**

举例：

- sudo cp /xxx/xxx/libxxx.so /usr/lib    					**库copy**
- sudo ln -s /xxx/xxx/libxxx.so /usr/lib/libxxx.so    			**创建软链接一般使用这种**

#### 2.7 优缺点

**静态库：**

优点：

静态库被打包到应用程序中加载速度快
发布程序无需提供静态库，移植方便
缺点：

相同的库文件数据可能在内存中被加载多份，消耗系统资源，浪费内存
库文件更新需要重新编译项目文件，生成新的可执行程序，浪费时间。

 **动态库**

优点：

可实现不同进程间的资源共享
动态库升级简单，只需要替换库文件，无需重新编译应用程序
程序猿可以控制何时加载动态库，不调用库函数动态库不会被加载
缺点：

加载速度比静态库慢，以现在计算机的性能可以忽略
发布程序需要提供依赖的动态库

### 3. Makefile

使用 GCC 的命令行进行程序编译在单个文件下是比较方便的，当工程中的文件逐渐增多，甚至变得十分庞大的时候，使用 GCC 命令编译就会变得力不从心。这种情况下我们需要借助项目构造工具 make 帮助我们完成这个艰巨的任务。 make 是一个命令工具，是一个解释 makefile 中指令的命令工具，一般来说，大多数的 IDE 都有这个命令，比如：Visual C++ 的 nmake，QtCreator 的 qmake 等。

make 工具在构造项目的时候需要加载一个叫做 makefile 的文件，makefile 关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile 定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile 就像一个 Shell 脚本一样，其中也可以执行操作系统的命令。

makefile 带来的好处就是 ——“自动化编译”，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。

makefile 文件有两种命名方式 makefile 和 Makefile，构建项目的时候在哪个目录下执行构建命令 make 这个目录下的 makefile 文件就会别加载，因此在一个项目中可以有多个 makefile 文件，分别位于不同的项目目录中。

#### 3.1 规则

Makefile 的框架是由规则构成的。make 命令执行时先在 Makefile 文件中查找各种规则，对各种规则进行解析后运行规则。规则的基本格式为：

**每条规则的语法格式:**

target1,target2...: depend1, depend2, ...
​	command
​	......
​	......

每条规则由三个部分组成分别是目标(target), 依赖(depend) 和命令(command)。

**命令(command): 当前这条规则的动作，一般情况下这个动作就是一个 shell 命令**

1. 通过某个命令编译文件、生成库文件、进入目录等。

2. 动作可以是多个，每个命令前必须有一个Tab缩进并且独占占一行。

**依赖(depend): 规则所必需的依赖条件，在规则的命令中可以使用这些依赖。**

- 生成可执行文件的目标文件（*.o）可以作为依赖使用

- 如果规则的命令中不需要任何依赖，那么规则的依赖可以为空
- 当前规则中的依赖可以是其他规则中的某个目标，这样就形成了规则之间的嵌套
- 依赖可以根据要执行的命令的实际需求，指定很多个

**目标(target)： 规则中的目标，这个目标和规则中的命令是对应的**

通过执行规则中的命令，可以生成一个和目标同名的文件
规则中可以有多个命令，因此可以通过这多条命令来生成多个目标，所有目标也可以有很多个
通过执行规则中的命令，可以只执行一个动作，不生成任何文件，这样的目标被称为伪目标

**通过一个例子来阐述一下**

```
# 举例: 有源文件 a.c b.c c.c head.h, 需要生成可执行程序 app
################# 例1 #################
app:a.c b.c c.c
	gcc a.c b.c c.c -o app

################# 例2 #################
# 有多个目标, 多个依赖, 多个命令
app,app1:a.c b.c c.c d.c
	gcc a.c b.c -o app
	gcc c.c d.c -o app1
	
################# 例3 #################	
# 规则之间的嵌套
app:a.o b.o c.o
	gcc a.o b.o c.o -o app
# a.o 是第一条规则中的依赖
a.o:a.c
	gcc -c a.c
# b.o 是第一条规则中的依赖
b.o:b.c
	gcc -c b.c
# c.o 是第一条规则中的依赖
c.o:c.c
	gcc -c c.c
```



#### 3.2 工作原理

##### 3.2.1 规则的执行

在调用 make 命令编译程序的时候，make 会首先找到 Makefile 文件中的第 1 个规则，分析并执行相关的动作。但是需要注意的是，好多时候要执行的动作（命令）中使用的依赖是不存在的，如果使用的依赖不存在，这个动作也就不会被执行。

对应的解决方案是先将需要的依赖生成出来，我们就可以在 makefile 中添加新的规则，将不存在的依赖作为这个新的规则中的目标，当这条新的规则对应的命令执行完毕，对应的目标就被生成了，同时另一条规则中需要的依赖也就存在了。

这样，makefile 中的某一条规则在需要的时候，就会被其他的规则调用，直到 makefile 中的第一条规则中的所有的依赖全部被生成，第一条规则中的命令就可以基于这些依赖生成对应的目标，make 的任务也就完成了。

```
# makefile
# 规则之间的嵌套
# 规则1
app:a.o b.o c.o
	gcc a.o b.o c.o -o app
# 规则2
a.o:a.c
	gcc -c a.c
# 规则3
b.o:b.c
	gcc -c b.c
# 规则4
c.o:c.c
	gcc -c c.c
```

在这个例子中，如果执行 make 命令就会根据这个 makefile 中的 4 条规则编译这三个源文件。在解析第一条规则的时候发现里边的三个依赖都是不存在的，因此规则对应的命令也就不能被执行。

当依赖不存在的时候，make 就是查找其他的规则，看哪一条规则是用来生成需要的这个依赖的，找到之后就会执行这条规则中的命令。因此规则 2， 规则 3， 规则 4 里的命令会相继被执行，当规则 1 中依赖全部被生成之后对应的命令也就被执行了，因此规则 1 的目标被生成，make 工作结束。

**知识点拓展: 如果想要执行 makefile 中非第一条规则对应的命令，那么就不能直接 make, 需要将那条规则的目标也写到 make 的后边，比如只需要执行规则 3 中的命令，就需要: make b.o。**

##### 3.2.2 文件的时间戳

make 命令执行的时候会根据文件的时间戳判定是否执行 makefile 文件中相关规则中的命令。

目标是通过依赖生成的，因此正常情况下：目标时间戳 > 所有依赖的时间戳 , 如果执行 make 命令的时候检测到规则中的目标和依赖满足这个条件，那么规则中的命令就不会被执行。

当依赖文件被更新了，文件时间戳也会随之被更新，这时候 目标时间戳 < 某些依赖的时间戳 , 在这种情况下目标文件会通过规则中的命令被重新生成。

如果规则中的目标对应的文件根本就不存在， 那么规则中的命令肯定会被执行。

```makefile
# makefile
# 规则之间的嵌套
# 规则1
app:a.o b.o c.o
	gcc a.o b.o c.o -o app
# 规则2
a.o:a.c
	gcc -c a.c
# 规则3
b.o:b.c
	gcc -c b.c
# 规则4
c.o:c.c
	gcc -c c.c

```

根据上文的描述，先执行 make 命令，基于这个 makefile 编译这几个源文件生成对应的目标文件。然后再修改例子中的 a.c, 再次通过 make 编译这几个源文件，那么这个时候先执行规则 2 更新目标文件 a.o， 然后再执行规则 1 更新目标文件 app，其余的规则是不会被执行的。

##### 3.2.3  自动推导

make 是一个功能强大的构建工具，虽然 make 需要根据 makefile 中指定的规则来完成源文件的编译。作为小白的我们编写 makefile 的时候难免写的不是那么严谨从而漏写一些构建规则，但是我们会发现程序还是会被编译成功。这是因为 make 有自动推导的能力，不会完全依赖 makefile。

比如：使用命令 make 编译扩展名为.c 的 C 语言文件的时候，源文件的编译规则不用明确给出。这是因为 make 进行编译的时候会使用一个默认的编译规则，按照默认规则完成对.c 文件的编译，生成对应的.o 文件。它使用命令 cc -c 来编译.c 源文件。在 Makefile 中只要给出需要构建的目标文件名（一个.o 文件），make 会自动为这个.o 文件寻找合适的依赖文件（对应的.c 文件），并且使用默认的命令来构建这个目标文件。

假设本地项目目录中有以下几个源文件:

```shell
$ tree
.
├── add.c
├── div.c
├── head.h
├── main.c
├── makefile
├── mult.c
└── sub.c
```

目录中 makefile 文件内容如下

```
# 这是一个完整的 makefile 文件
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
```

通过 make 构建项目:

```
$ make
cc    -c -o add.o add.c
cc    -c -o div.o div.c
cc    -c -o main.o main.c
cc    -c -o mult.o mult.c
cc    -c -o sub.o sub.c
gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
```

**我们可以发现上边的 makefile 文件中只有一条规则，依赖中所有的 .o 文件在本地项目目录中是不存在的，并且也没有其他的规则用来生成这些依赖文件，这时候 make 会使用内部默认的构造规则先将这些依赖文件生成出来，然后在执行规则中的命令，最后生成目标文件 calc。**

#### 3.3 变量

使用 Makefile 进行规则定义的时候，为了写起来更加灵活，我们可以在里边使用变量。makefile 中的变量分为三种：自定义变量，预定义变量和自动变量。

##### 3.3.1 自定义变量

- 用 Makefile 进行规则定义的时候，用户可以定义自己的变量，称为用户自定义变量。**makefile 中的变量是没有类型的，直接创建变量然后给其赋值就可以了。**

```
# 错误, 只创建了变量名, 没有赋值
变量名 
# 正确, 创建一个变量名并且给其赋值
变量名=变量值
```

- **在给 makefile 中的变量赋值之后，如何在需要的时候将变量值取出来呢？**

```
# 如果将变量的值取出?
$(变量的名字)

# 举例 add.o  div.o  main.o  mult.o  sub.o
# 定义变量并赋值
obj=add.o  div.o  main.o  mult.o  sub.o
# 取变量的值
$(obj)
```

自定义变量使用举例：

```
# 这是一个规则，普通写法
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
        
# 这是一个规则，里边使用了自定义变量
obj=add.o  div.o  main.o  mult.o  sub.o
target=calc
$(target):$(obj)
        gcc  $(obj) -o $(target)
```

##### 3.3.2 预定义变量

在 Makefile 中有一些已经定义的变量，用户可以直接使用这些变量，不用进行定义。在进行编译的时候，某些条件下 Makefile 会使用这些预定义变量的值进行编译。这些预定义变量的名字一般都是大写的，经常采用的预定义变量如下表所示：

![1658805328946](C:\Users\Tokin_hardware\AppData\Roaming\Typora\typora-user-images\1658805328946.png)

```
# 这是一个规则，普通写法
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
        
# 这是一个规则，里边使用了自定义变量和预定义变量
obj=add.o  div.o  main.o  mult.o  sub.o
target=calc
CFLAGS=-O3 # 代码优化
$(target):$(obj)
        $(CC)  $(obj) -o $(target) $(CFLAGS)
```

**3.3.3 自动变量**

Makefile 中的变量除了用户自定义变量和预定义变量外，还有一类自动变量。Makefile 中的规则语句中经常会出现目标文件和依赖文件，自动变量用来代表这些规则中的目标文件和依赖文件，并且它们只能在规则的命令中使用。

下表中是一些常见的自动变量。

| 变 量 | 含 义                                                        |
| ----- | ------------------------------------------------------------ |
| $*    | 表示目标文件的名称，不包含目标文件的扩展名                   |
| $+    | 表示所有的依赖文件，这些依赖文件之间以空格分开，按照出现的先后为顺序，其中可能 包含重复的依赖文件 |
| $<    | 表示依赖项中第一个依赖文件的名称                             |
| $?    | 依赖项中，所有比目标文件时间戳晚的依赖文件，依赖文件之间以空格分开 |
| $@    | 表示目标文件的名称，包含文件扩展名                           |
| $^    | 依赖项中，所有不重复的依赖文件，这些文件之间以空格分开       |

下面几个例子，演示一下自动变量如何使用。

```
# 这是一个规则，普通写法
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
        
# 这是一个规则，里边使用了自定义变量
# 使用自动变量, 替换相关的内容
calc:add.o  div.o  main.o  mult.o  sub.o
	gcc $^ -o $@ 			# 自动变量只能在规则的命令中使用
```

**举例：**

```
# 这是一个规则，普通写法
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
        
# 这是一个规则，里边使用了自定义变量
# 使用自动变量, 替换相关的内容
calc:add.o  div.o  main.o  mult.o  sub.o
	gcc $^ -o $@ 			# 自动变量只能在规则的命令中使用
```

#### 3.4 模式匹配

介绍概念之前，先读一下下面的这个 makefile 文件:

```
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
# 语法格式重复的规则, 将 .c -> .o, 使用的命令都是一样的 gcc *.c -c
add.o:add.c
        gcc add.c -c

div.o:div.c
        gcc div.c -c

main.o:main.c
        gcc main.c -c

sub.o:sub.c
        gcc sub.c -c

mult.o:mult.c
        gcc mult.c -c
```

在阅读过程中能够发现从第二个规则开始到第六个规则做的是相同的事情，但是由于文件名不同不得不在文件中写出多个规则，这就让 makefile 文件看起来非常的冗余，我们可以将这一系列的相同操作整理成一个模板，所有类似的操作都通过模板去匹配 makefile 会因此而精简不少，只是可读性会有所下降。

这个规则模板可以写成下边的样子，这种操作就称之为模式匹配。

```
# 模式匹配 -> 通过一个公式, 代表若干个满足条件的规则
# 依赖有一个, 后缀为.c, 生成的目标是一个 .o 的文件, % 是一个通配符, 匹配的是文件名
%.o:%.c
	gcc $< -c
```

#### 3.5 函数

makefile 中有很多函数并且所有的函数都是有返回值的。makefile 中函数的格式和 C/C++ 中函数也不同，其写法是这样的： $(函数名 参数1, 参数2, 参数3, ...)，主要目的是让我们能够快速方便的得到函数的返回值。

这里为大家介绍两个 makefile 中使用频率比较高的函数：wildcard 和 patsubst。

##### 3.5.1 wildcard

这个函数的主要作用是获取指定目录下指定类型的文件名，其返回值是以空格分割的、指定目录下的所有符合条件的文件名列表。函数原型如下：

```
# 该函数的参数只有一个, 但是这个参数可以分成若干个部分, 通过空格间隔
$(wildcard PATTERN...)
	参数:	指定某个目录, 搜索这个路径下指定类型的文件，比如： *.c
```

参数功能:

- PATTERN 指的是某个或多个目录下的对应的某种类型的文件，比如当前目录下的.c 文件可以写成 *.c

- 可以指定多个目录，每个路径之间使用空格间隔 

返回值：

- 得到的若干个文件的文件列表， 文件名之间使用空格间隔

示例：$(wildcard *.c ./sub/*.c)

- 返回值格式: a.c b.c c.c d.c e.c f.c ./sub/aa.c ./sub/bb.c

##### 3.5.2 函数使用举例:

```
# 使用举例: 分别搜索三个不同目录下的 .c 格式的源文件
src = $(wildcard /home/robin/a/*.c /home/robin/b/*.c *.c)  # *.c == ./*.c
# 返回值: 得到一个大的字符串, 里边有若干个满足条件的文件名, 文件名之间使用空格间隔
/home/robin/a/a.c /home/robin/a/b.c /home/robin/b/c.c /home/robin/b/d.c e.c f.c
```

##### 3.5.3 patsubst

这个函数的功能是按照指定的模式替换指定的文件名的后缀，函数原型如下:

```
# 有三个参数, 参数之间使用 逗号间隔
$(patsubst <pattern>,<replacement>,<text>)
```

参数功能:

- pattern: 这是一个模式字符串，需要指定出要被替换的文件名中的后缀是什么

  文件名和路径不需要关心，因此使用 % 表示即可 [通配符是 %]
  在通配符后边指定出要被替换的后缀，比如: %.c, 意味着 .c 的后缀要被替换掉

- replacement: 这是一个模式字符串，指定参数 pattern 中的后缀最终要被替换为什么

  还是使用 % 来表示参数 pattern 中文件的路径和名字
  在通配符 % 后边指定出新的后缀名，比如: %.o 这表示原来的后缀被替换为 .o

- text: 该参数中存储这要被替换的原始数据

- 返回值:

​	函数返回被替换过后的字符串。

**函数使用举例:**

```
src = a.cpp b.cpp c.cpp e.cpp
# 把变量 src 中的所有文件名的后缀从 .cpp 替换为 .o
obj = $(patsubst %.cpp, %.o, $(src)) 
# obj 的值为: a.o b.o c.o e.o
```

#### 3.6 Makefile 最终写法

```
# 添加自定义变量 -> makefile中注释前 使用 # 
# 使用函数搜索当前目录下的源文件 .c
src=$(wildcard *.c)
# 将源文件的后缀替换为 .o
obj=$(patsubst %.c, %.o, $(src))
target=calc

$(target):$(obj)
        gcc $(obj)  -o $(target)

%.o:%.c
        gcc $< -c

# 添加规则, 删除生成文件 *.o 可执行程序
# 声明clean为伪文件
.PHONY:clean
clean:
        # shell命令前的 - 表示强制这个指令执行, 如果执行失败也不会终止
        -rm $(obj) $(target) 
        echo "hello, 我是测试字符串"
```



   2. 如果规则的命令中不需要任何依赖，那么规则的依赖可以为空

   3. 当前规则中的依赖可以是其他规则中的某个目标，这样就形成了规则之间的嵌套

   4. 依赖可以根据要执行的命令的实际需求，指定很多个	

   5. 

   6. 

   7. 目标(target)： 规则中的目标，这个目标和规则中的命令是对应的

      通过执行规则中的命令，可以生成一个和目标同名的文件
      规则中可以有多个命令，因此可以通过这多条命令来生成多个目标，所有目标也可以有很多个
      通过执行规则中的命令，可以只执行一个动作，不生成任何文件，这样的目标被称为伪目标

      作者: 苏丙榅
      链接: https://subingwen.cn/linux/makefile/#1-%E8%A7%84%E5%88%99
      来源: 爱编程的大丙
      著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。