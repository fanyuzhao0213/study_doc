# linux应用学习

## 5.文件属性与目录

### 5.1 Linux 系统中的文件类型 

Linux 系统下一共分为 7 种文件类型，下面依次给大家介绍。 

#### 5.1.1 普通文件 

普通文件可以分为两大类：文本文件和二进制文件。
⚫ 文本文件： 文件中的内容是由文本构成的，所谓文本指的是 ASCII 码字符。文件中的内容其本质
上都是数字（因为计算机本身只有 0 和 1，存储在磁盘上的文件内容也都是由 0 和 1 所构成），而
文本文件中的数字应该被理解为这个数字所对应的 ASCII 字符码；譬如常见的.c、 .h、 .sh、 .txt 等
这些都是文本文件，文本文件的好处就是方便人阅读、浏览以及编写。
⚫ 二进制文件： 二进制文件中存储的本质上也是数字，只不过对于二进制文件来说， 这些数字并不是
文本字符编码，而是真正的数字。譬如 Linux 系统下的可执行文件、 C 代码编译之后得到的.o 文
件、 .bin 文件等都是二进制文件 。

**在 Linux 系统下，可以通过 stat 命令或者 ls 命令来查看文件类型** 

⚫ ' - '：普通文件
⚫ ' d '：目录文件
⚫ ' c '：字符设备文
⚫ ' b '：块设备文件
⚫ ' l '：符号链接文
⚫ ' s '：套接字文件
⚫ ' p '：管道文件 



#### 5.1.2 目录文件 

文件夹中记录了该文件夹本省的路径以及该文件夹下所存放的文件。文件夹作为一种特殊文
件，本身并不适合使用前面给大家介绍的文件 I/O 的方式来读写，在 Linux 系统下，会有一些专门的系统调用用于读写文件夹 



#### 5.1.3 字符设备文件和块设备文件 

Linux 系统中，可将硬件设备分为字符设备和块设备，所以就有了字符设备文件和块设备文件两种文件
类型。虽然有设备文件，但是设备文件并不对应磁盘上的一个文件，也就是说设备文件并不存在于磁盘中，
而是由文件系统虚拟出来的，一般是由内存来维护， 当系统关机时，设备文件都会消失； 字符设备文件一般
存放在 Linux 系统/dev/目录下，所以/dev 也称为虚拟文件系统 devfs 



#### 5.1.4 符号链接文件 

符号链接文件（link） 类似于 Windows 系统中的快捷方式文件，是一种特殊文件，它的内容指向的是另
一个文件路径，当对符号链接文件进行操作时，系统根据情况会对这个操作转移到它指向的文件上去，而不
是对它本身进行操作，譬如，读取一个符号链接文件内容时，实际上读到的是它指向的文件的内容。
如果大家理解了 Windows 下的快捷方式，那么就会很容易理解 Linux 下的符号链接文件。 图 5.1.4 中
的 cdrom、 cdrw、 fd、 initctl 等这些文件都是符号链接文件，箭头所指向的文件路径便是符号链接文件所指
向的文件。 

#### 5.1.5 管道文件 

管道文件（pipe） 主要用于进程间通信 



#### 5.1.6 套接字文件 

套接字文件（socket）也是一种进程间通信的方式，与管道文件不同的是，它们可以在不同主机上的进
程间通信，实际上就是网络通信 



#### **5.1.7 总结**

普通文件是最常见的文件类型；
目录也是一种文件类型；
设备文件对应于硬件设备；
符号链接文件类似于 Windows 的快捷方式；
管道文件用于进程间通信；
套接字文件用于网络通信。 



### 5.2 stat 函数 

Linux 下可以使用 stat 命令查看文件的属性，其实这个命令内部就是通过调用 stat()函数来获取文件属
性的， stat 函数是 Linux 中的系统调用，用于获取文件相关的信息 

int stat(const char *pathname, struct stat *buf);
首先使用该函数需要包含<sys/types.h>、 <sys/stat.h>以及<unistd.h>这三个头文件。 

pathname： 用于指定一个需要查看属性的文件路径。
buf： struct stat 类型指针，用于指向一个 struct stat 结构体变量。调用 stat 函数的时候需要传入一个 structstat 变量的指针， 获取到的文件属性信息就记录在 struct stat 结构体中，稍后给大家介绍 struct stat 结构体中
有记录了哪些信息。
返回值： 成功返回 0；失败返回-1，并设置 error。 

#### 5.2.1 struct stat 结构体 

```
struct stat
{
    dev_t st_dev; /* 文件所在设备的 ID */
    ino_t st_ino; /* 文件对应 inode 节点编号 */
    mode_t st_mode; /* 文件对应的模式 */
    nlink_t st_nlink; /* 文件的链接数 */
    uid_t st_uid; /* 文件所有者的用户 ID */
    gid_t st_gid; /* 文件所有者的组 ID */
    dev_t st_rdev; /* 设备号（指针对设备文件） */
    off_t st_size; /* 文件大小（以字节为单位） */
    blksize_t st_blksize; /* 文件内容存储的块大小 */
    blkcnt_t st_blocks; /* 文件内容所占块数 */
    struct timespec st_atim; /* 文件最后被访问的时间 */
    struct timespec st_mtim; /* 文件内容最后被修改的时间 */
    struct timespec st_ctim; /* 文件状态最后被改变的时间 */
};
    
```



#### 5.2.2 st_mode 变量 

st_mode 是 struct stat 结构体中的一个成员变量， 是一个 32 位无符号整形数据，该变量记录了文件的类型、文件的权限这些信息，其表示方法如下所示 :

| 0000     | 000  | 000  | 000  | 000  |
| -------- | ---- | ---- | ---- | ---- |
| 文件类型 | S    | U    | G    | O    |

O 对应的 3 个 bit 位用于描述其它用户的权限；
G 对应的 3 个 bit 位用于描述同组用户的权限；
U 对应的 3 个 bit 位用于描述文件所有者的权限；
S 对应的 3 个 bit 位用于描述文件的特殊权限。 

这些 bit 位表达内容与 open 函数的 mode 参数相对应，这里不再重述。同样， 在 mode 参数中表示权限的宏定义，在这里也是可以使用的， 这些宏定义如下（以下数字使用的是八进制方式表示） ： 

```
S_IRWXU 00700 owner has read, write, and execute permission
S_IRUSR 00400 owner has read permission
S_IWUSR 00200 owner has write permission
S_IXUSR 00100 owner has execute permission
S_IRWXG 00070 group has read, write, and execute permission
S_IRGRP 00040 group has read permission
S_IWGRP 00020 group has write permission
S_IXGRP 00010 group has execute permission
S_IRWXO 00007 others (not in group) have read, write, and execute permission
S_IROTH 00004 others have read permission
S_IWOTH 00002 others have write permission
S_IXOTH 00001 others have execute permission
```

这里我们重点来看看“文件类型”这 4 个 bit 位， 这 4 个 bit 位用于描述该文件的类型，譬如该文件是
普通文件、还是链接文件、亦或者是一个目录等，那么就可以通过这 4 个 bit 位数据判断出来，如下所示 :

```
S_IFSOCK 0140000 socket（套接字文件）
S_IFLNK 0120000 symbolic link（链接文件）
S_IFREG 0100000 regular file（普通文件）
S_IFBLK 0060000 block device（块设备文件）
S_IFDIR 0040000 directory（目录）
S_IFCHR 0020000 character device（字符设备文件）
S_IFIFO 0010000 FIFO（管道文件）
```

在 C 语言中，八进制方式表示一个数字需要在数字
前面添加一个 0（零） 。所以由上面可知，当“文件类型”这 4 个 bit 位对应的数字是 14（八进制）时，表示该文件是一个套接字文件、当“文件类型”这 4 个 bit 位对应的数字是 12（八进制）时，表示该文件是一个链接文件、当“文件类型”这 4 个 bit 位对应的数字是 10（八进制）时，表示该文件是一个普通文件等 

- /* 判断是不是普通文件 */
- if ((st.st_mode & S_IFMT) == S_IFREG) {
- /* 是 */
- } 

除了这样判断之外，我们还可以使用 Linux 系统封装好的宏来进行判断，如下所示 

```
S_ISREG(m) #判断是不是普通文件，如果是返回 true，否则返回 false
S_ISDIR(m) #判断是不是目录，如果是返回 true，否则返回 false
S_ISCHR(m) #判断是不是字符设备文件，如果是返回 true，否则返回 false
S_ISBLK(m) #判断是不是块设备文件，如果是返回 true，否则返回 false
S_ISFIFO(m) #判断是不是管道文件，如果是返回 true，否则返回 false
S_ISLNK(m) #判断是不是链接文件，如果是返回 true，否则返回 false
S_ISSOCK(m) #判断是不是套接字文件，如果是返回 true，否则返回 false
```

**有了这些宏之后，就可以通过如下方式来判断文件类型了：** 

```
/* 判断是不是普通文件 */
if (S_ISREG(st.st_mode)) {
/* 是 */
}
/* 判断是不是目录 */
if (S_ISDIR(st.st_mode)) {
/* 是 */
}
```



#### 5.2.3 struct timespec 结构体 

该结构体定义在<time.h>头文件中， 是 Linux 系统中时间相关的结构体 

```
struct timespec
{
	time_t tv_sec; /* 秒 */
	syscall_slong_t tv_nsec; /* 纳秒 */
};
```

struct timespec 结构体中只有两个成员变量，一个秒（tv_sec） 、一个纳秒（tv_nsec）， time_t 其实指的就是 long int 类型， 所以由此可知，该结构体所表示的时间可以精确到纳秒 

在 Linux 系统中， time_t 时间指的是一个时间段，从某一个时间点到某一个时间点所经过的秒数， 譬如
对于文件的三个时间属性来说，指的是从过去的某一个时间点（这个时间点是一个起始基准时间点）到文件最后被访问、 文件内容最后被修改、 文件状态最后被改变的这个时间点所经过的秒数。 time_t 时间在 Linux下被称为日历时间 

### 5.3 fstat 和 lstat 函数 

前面给大家介绍了 stat 系统调用，起始除了 stat 函数之外，还可以使用 fstat 和 lstat 两个系统调用来获
取文件属性信息 。



#### 5.3.1 fstat 函数 

fstat 与 stat 区别在于， stat 是从文件名出发得到文件属性信息，不需要先打开文件；而 fstat 函数则是从文件描述符出发得到文件属性信息，所以使用 fstat 函数之前需要先打开文件得到文件描述符 

int fstat(int fd, struct stat *buf);
**第一个参数 fd 表示文件描述符，第二个参数以及返回值与 stat 一样** 

#### **5.3.2 lstat 函数** 

stat()与 stat、 fstat 的区别在于，对于符号链接文件， stat、 fstat 查阅的是符号链接文件所指向的文件对应的文件属性信息，而 lstat 查阅的是符号链接文件本身的属性信息 

int lstat(const char *pathname, struct stat *buf);
函数参数列表、返回值与 stat 函数一样，使用方法也一样，这里不再重述！ 

### 5.4 文件属主 

在 Linux 中，系统并不是通过用户名或用户组名来识别不同的用户和用户组，而是通过 ID。 ID 就是一个编号， Linux 系统会为每一个用户或用户组分配一个 ID， 将用户名或用户组名与对应的 ID 关联起来， 所以系统通过用户 ID（UID） 或组 ID（GID） 就可以识别出不同的用户和用户组。 

Tips： 用户 ID 简称 UID、用户组 ID 简称 GID。  



文件的用户 ID 和组 ID 分别由 struct stat 结构体中的 st_uid 和 st_gid 所指定。 既然 Linux 下的每一个文件都有与之相关联的用户 ID 和组 ID，那么对于一个进程来说亦是如此，与一个进程相关联的 ID 有 5 个或更多。

- 实际用户 ID 和实际组 ID 标识我们究竟是谁，也就是执行该进程的用户是谁、以及该用户对应的

  所属组； 实际用户 ID 和实际组 ID 确定了进程所属的用户和组。 

- 进程的有效用户 ID、有效组 ID 以及附属组 ID 用于文件访问权限检查，详情请查看 5.4.1 小节内

  容。 

#### 5.4.1 有效用户 ID 和有效组 ID 

首先对于有效用户 ID 和有效组 ID 来说，这是进程所持有的概念，对于文件来说，并无此属性！ 有效
用户 ID 和有效组 ID 是站在操作系统的角度，用于给操作系统判断当前执行该进程的用户在当前环境下对某个文件是否拥有相应的权限。 

在 Linux 系统中，当进程对文件进行读写操作时，系统首先会判断该进程是否具有对该文件的读写权
限，那如何判断呢？自然是通过该文件的权限位来判断， struct stat 结构体中的 st_mode 字段中就记录了该
文件的权限位以及文件类型。关于文件权限检查相关内容将会在 5.5 小节中说明。
当进行权限检查时，并不是通过进程的实际用户和实际组来参与权限检查的，而是通过有效用户和有效
组来参与文件权限检查。 通常， 绝大部分情况下，进程的有效用户等于实际用户（有效用户 ID 等于实际用户 ID） ，有效组等于实际组（有效组 ID 等于实际组 ID） 

#### **5.4.2 chown 函数** 

chown 是一个系统调用，该系统调用可用于改变文件的所有者（用户 ID）和所属组（组 ID） 。其实在
Linux 系统下也有一个 chown 命令，该命令的作用也是用于改变文件的所有者和所属组，譬如testApp.c文件的所有者和所属组修改为 root： 

**sudo chown root:root testApp.c** 

int chown(const char *pathname, uid_t owner, gid_t group);
首先，使用该命令需要包含头文件<unistd.h>。
函数参数和返回值如下所示：
pathname： 用于指定一个需要修改所有者和所属组的文件路径。
owner： 将文件的所有者修改为该参数指定的用户（以用户 ID 的形式描述） ；
group： 将文件的所属组修改为该参数指定的用户组（以用户组 ID 的形式描述）；
返回值： 成功返回 0；失败将返回-1，兵并且会设置 errno。 

### 5.5 文件访问权限 

struct stat 结构体中的 st_mode 字段记录了文件的访问权限位。当提及到文件时，指的是前面给大家介
绍的任何类型的文件，并不仅仅指的是普通文件；所有文件类型（目录、设备文件）都有访问权限（accesspermission），可能有很多人认为只有普通文件才有访问权限，这是一种误解 

#### 5.5.1 普通权限和特殊权限 

文件的权限可以分为两个大类，分别是普通权限和特殊权限（也可称为附加权限）。普通权限包括对文
件的读、写以及执行，而特殊权限则包括一些对文件的附加权限，譬如 Set-User-ID、Set-Group-ID以及 Sticky。
接下来，分别对普通权限和特殊权限进行介绍。 

**普通权限**  ：

每个文件都有 9 个普通的访问权限位，可将它们分为 3 类 

| st_mode 权限表示宏    | 含义                                                    |
| --------------------- | ------------------------------------------------------- |
| S_IRUSR
S_IWUSR
S_IXUSR | 文件所有者读权限<br/>文件所有者写权限
文件所有者执行权限 |
| S_IRGRP
S_IWGRP
S_IXGRP | 同组用户读权限<br/>同组用户写权限
同组用户执行权限       |
| S_IROTH
S_IWOTH
S_IXOTH | 其它用户读权限<br/>其它用户写权限
其它用户执行权限       |

-RWX   RWX    R-X

最前面的一个字符表示该文件的类型，这个前面给大家介绍过， " - "表示该文件是一个普通文件。
r 表示具有读权限；
w 表示具有写权限；
x 表示具有执行权限；
-表示无此权限。 

**特殊权限** :

st_mode 字段中除了记录文件的 9 个普通权限之外，还记录了文件的 3 个特殊权限，也就是图 5.2.1 中
所表示的 S 字段权限位， S 字段三个 bit 位中，从高位到低位依次表示文件的 set-user-ID 位权限、 set-groupID 位权限以及 sticky 位权限 

| 特殊权限 | 含义                |
| -------- | ------------------- |
| S_ISUID  | set-user-ID 位权限  |
| S_ISGID  | set-group-ID 位权限 |
| S_ISVTX  | Sticky 位权限       |

这三种权限分别使用 S_ISUID、 S_ISGID 和 S_ISVTX 三个宏来表示： 

```
S_ISUID 04000 set-user-ID bit
S_ISGID 02000 set-group-ID bit (see below)
S_ISVTX 01000 sticky bit (see below)
```

同样，以上数字使用的是八进制方式表示。 对应的 bit 位数字为 1，则表示设置了该权限、为 0 则表示
并未设置该权限； 譬如通过 st_mode 变量判断文件是否设置了 set-user-ID 位权限，代码如下 

```
if (st.st_mode & S_ISUID) {
//设置了 set-user-ID 位权限
} else {
//没有设置 set-user-ID 位权限
}
```

这三个权限位具体有什么作用呢？ 接下里给大家简单地介绍一下：
⚫ 当进程对文件进行操作的时候、将进行权限检查，如果文件的 set-user-ID 位权限被设置，内核会将
进程的有效 ID 设置为该文件的用户 ID（文件所有者 ID） ，意味着该进程直接获取了文件所有者
的权限、以文件所有者的身份操作该文件。
⚫ 当进程对文件进行操作的时候、将进行权限检查，如果文件的 set-group-ID 位权限被设置，内核会
将进程的有效用户组 ID 设置为该文件的用户组 ID（文件所属组 ID） ，意味着该进程直接获取了
文件所属组成员的权限、以文件所属组成员的身份操作该文件。 

#### 5.5.2 目录权限 

那说明删除文件、创建文件这些操作也是需要相应权限的，那这些权限又是从哪里获取的呢？答案就是
目录。 目录（文件夹）在 Linux 系统下也是一种文件，拥有与普通文件相同的权限方案（S/U/G/O） ，只是
这些权限的含义另有所指。
⚫ 目录的读权限： 可列出（譬如：通过 ls 命令） 目录之下的内容（即目录下有哪些文件）。
⚫ 目录的写权限： 可以在目录下创建文件、删除文件。
⚫ 目录的执行权限： 可访问目录下的文件，譬如对目录下的文件进行读、写、执行等操作。 

#### 5.5.3 检查文件权限 access 

件的权限检查不单单只讨论文件本身的权限，还需要涉及到文件
所在目录的权限， 只有同时都满足了，才能通过操作系统的权限检查，进而才可以对文件进行相关操作；所
以，程序当中对文件进行相关操作之前，需要先检查执行进程的用户是否对该文件拥有相应的权限。那如何
检查呢？可以使用 access 系统调用，函数原型如下 

int access(const char *pathname, int mode);
首先，使用该函数需要包含头文件<unistd.h>。
函数参数和返回值含义如下：
pathname： 需要进行权限检查的文件路径。
mode： 该参数可以取以下值：
⚫ F_OK：检查文件是否存在 

⚫ R_OK：检查是否拥有读权限
⚫ W_OK：检查是否拥有写权限
⚫ X_OK：检查是否拥有执行权限
除了可以单独使用之外，还可以通过按位或运算符" | "组合在一起。
返回值： 检查项通过则返回 0，表示拥有相应的权限并且文件存在；否则返回-1，如果多个检查项组合
在一起，只要其中任何一项不通过都会返回-1。 

#### 5.5.4 修改文件权限 chmod 

在 Linux 系统下，可以使用 chmod 命令修改文件权限，该命令内部实现方法其实是调用了 chmod 函数，chmod 函数是一个系统调用，函数原型如下所示 

int chmod(const char *pathname, mode_t mode);
首先，使用该函数需要包含头文件<sys/stat.h>。
函数参数及返回值如下所示：
pathname： 需要进行权限修改的文件路径，若该参数所指为符号链接，实际改变权限的文件是符号链
接所指向的文件，而不是符号链接文件本身。
mode： 该参数用于描述文件权限，与 open 函数的第三个参数一样，这里不再重述，可以直接使用八进制数据来描述，也可以使用相应的权限宏（单个或通过位或运算符" | "组合）。
返回值： 成功返回 0；失败返回-1，并设置 errno。
文件权限对于文件来说是非常重要的属性，是不能随随便便被任何用户所修改的， 要想更改文件权限，
要么是超级用户（root） 进程、要么进程有效用户 ID 与文件的用户 ID（文件所有者）相匹配。 

**fchmod 函数**
该函数功能与 chmod 一样，参数略有不同。 fchmod()与 chmod()的区别在于使用了文件描述符来代替文件路径，就像是 fstat 与 stat 的区别。 

#### 5.5.5 umask 函数 

在 Linux 下有一个 umask 命令，在 Ubuntu 系统下执行看看： 

umask
命令用于查看/设置权限掩码， 权限掩码主要用于对新建文件的权限进行屏蔽。权限掩码的表示方式与文件权限的表示方式相同， 但是需要去除特殊权限位， umask 不能对特殊权限位进行屏蔽 

当新建文件时，文件实际的权限并不等于我们所设置的权限，譬如：调用 open 函数新建文件时，文件
实际的权限并不等于 mode 参数所描述的权限，而是通过如下关系得到实际权限： 

```
mode & ~umask
```

譬如调用 open 函数新建文件时， mode 参数指定为 0777， 假设 umask 为 0002，那么实际权限为 :

```
0777 & (~0002) = 0775
```

umask 权限掩码是进程的一种属性，用于指明该进程新建文件或目录时，应屏蔽哪些权限位。 进程的
umask 通常继承至其父进程（关于父、 子进程相关的内容将会在后面章节给大家介绍） ，譬如在 Ubuntu shell终端下执行的应用程序，它的 umask 继承至该 shell 进程。 

mode_t umask(mode_t mask);
首先，使用该命令需要包含头文件<sys/types.h>和<sys/stat.h>。
函数参数和返回值含义如下：
mask： 需要设置的权限掩码值，可以发现 make 参数的类型与 open 函数、 chmod 函数中的 mode 参数对应的类型一样，所以其表示方式也是一样的，前面也给大家介绍了，既可以使用数字表示（譬如八进制数）也可以直接使用宏（S_IRUSR、 S_IWUSR 等）。
返回值： 返回设置之前的 umask 值，也就是旧的 umask。 

### 5.6 文件的时间属性 

前面给大家介绍了 3 个文件的时间属性： 文件最后被访问的时间、 文件内容最后被修改的时间以及文
件状态最后被改变的时间，分别记录在 struct stat 结构体的 st_atim、 st_mtim 以及 st_ctim 变量中，如下所示 

| 字段    | 说明                     |
| ------- | ------------------------ |
| st_atim | 文件最后被访问的时间     |
| st_mtim | 文件内容最后被修改的时间 |
| st_ctim | 文件状态最后被改变的时间 |

⚫ 文件最后被访问的时间： 访问指的是读取文件内容，文件内容最后一次被读取的时间，譬如使用
read()函数读取文件内容便会改变该时间属性；
⚫ 文件内容最后被修改的时间： 文件内容发生改变，譬如使用 write()函数写入数据到文件中便会改变
该时间属性；
⚫ 文件状态最后被改变的时间： 状态更改指的是该文件的 inode 节点最后一次被修改的时间，譬如更
改文件的访问权限、更改文件的用户 ID、用户组 ID、更改链接数等，但它们并没有更改文件的实
际内容，也没有访问（读取）文件内容。 为什么文件状态的更改指的是 inode 节点的更改呢？ 3.1 小
节给大家介绍 inode 节点的时候给大家介绍过， inode 中包含了很多文件信息，譬如：文件字节大
小、文件所有者、文件对应的读/写/执行权限、文件时间戳（时间属性）、文件数据存储的 block
（块）等，所以由此可知，状态的更改指的就是 inode 节点内容的更改。譬如 chmod()、 chown()等
这些函数都能改变该时间属性。 

#### 5.6.1 utime()、 utimes()修改时间属性 

文件的时间属性虽然会在我们对文件进行相关操作（譬如：读、写）的时候发生改变，但这些改变都是
隐式、被动的发生改变，除此之外，还可以使用 Linux 系统提供的系统调用显式的修改文件的时间属性。本小节给大家介绍如何使用 utime()和 utimes()函数来修改文件的时间属性。
**Tips：只能显式修改文件的最后一次访问时间和文件内容最后被修改的时间，不能显式修改文件状态最后被改变的时间，大家可以想一想为什么？笔者把这个作为思考题留给大家！** 



**utime()函数** 

int utime(const char *filename, const struct utimbuf *times);
首先，使用该函数需要包含头文件<sys/types.h>和<utime.h>。
函数参数和返回值含义如下：
filename： 需要修改时间属性的文件路径。
times： 将时间属性修改为该参数所指定的时间值， times 是一个 struct utimbuf 结构体类型的指针，稍后给大家介绍，如果将 times 参数设置为 NULL，则会将文件的访问时间和修改时间设置为系统当前时间。
返回值： 成功返回值 0；失败将返回-1，并会设置 errno。 

来看看 struct utimbuf 结构体： 

```
struct utimbuf {
	time_t actime; /* 访问时间 */
	time_t modtime; /* 内容修改时间 */
};
```

该结构体中包含了两个 time_t 类型的成员，分别用于表示访问时间和内容修改时间， time_t 类型其实就是 long int 类型，所以这两个时间是以秒为单位的，所以由此可知， utime()函数设置文件的时间属性精度只能到秒 

同样对于文件来说，时间属性也是文件非常重要的属性之一，对文件时间属性的修改也不是任何用户都
可以随便修改的， 只有以下两种进程可对其进行修改：
⚫ 超级用户进程（以 root 身份运行的进程） 。
⚫ 有效用户 ID 与该文件用户 ID（文件所有者）相匹配的进程。
⚫ 在参数 times 等于 NULL 的情况下，对文件拥有写权限的进程。
除以上三种情况之外的用户进程将无法对文件时间戳进行修改。 

**utimes()函数**

utimes()也是系统调用，功能与 utime()函数一致，只是参数、细节上有些许不同， utimes()与 utime()最大
的区别在于前者可以以微秒级精度来指定时间值， 

#### 5.6.2 futimens()、 utimensat()修改时间属性 

除了上面给大家介绍了两个系统调用外，这里再向大家介绍两个系统调用，功能与 utime()和 utimes()函
数功能一样，用于显式修改文件时间戳，它们是 futimens()和 utimensat()。
这两个系统调用相对于 utime 和 utimes 函数有以下三个优点：
⚫ 可按纳秒级精度设置时间戳。 相对于提供微秒级精度的 utimes()，这是重大改进！
⚫ 可单独设置某一时间戳。譬如，只设置访问时间、而修改时间保持不变，如果要使用 utime()或 utimes()
来实现此功能，则需要首先使用 stat()获取另一个时间戳的值，然后再将获取值与打算变更的时间
戳一同指定。
⚫ 可独立将任一时间戳设置为当前时间。使用 utime()或 utimes()函数虽然也可以通过将 times 参数设
置为 NULL 来达到将时间戳设置为当前时间的效果，但是不能单独指定某一个时间戳，必须全部
设置为当前时间（不考虑使用额外函数获取当前时间的方式，譬如 time()） 

### 5.7 符号链接（软链接）与硬链接 

在 Linux 系统中有两种链接文件，分为软链接（也叫符号链接）文件和硬链接文件，软链接文件也就是
前面给大家的 Linux 系统下的七种文件类型之一，其作用类似于 Windows 下的快捷方式 

**Tips：使用 ln 命令可以为一个文件创建软链接文件或硬链接文件，用法如下：
​		硬链接： ln 源文件 链接文件
​		软链接： ln -s 源文件 链接文件** 

对于硬链接来说， 存在一些限制情况，如下：
⚫ 不能对目录创建硬链接（超级用户可以创建，但必须在底层文件系统支持的情况下）。
⚫ 硬链接通常要求链接文件和源文件位于同一文件系统中。
而软链接文件的使用并没有上述限制条件，优点如下所示：
⚫ 可以对目录创建软链接；
⚫ 可以跨越不同文件系统；
⚫ 可以对不存在的文件创建软链接。 



#### 5.7.1 创建链接文件 

**创建硬链接 link()** 

int link(const char *oldpath, const char *newpath);
首先，使用该函数需要包含头文件<unistd.h>。
函数原型和返回值含义如下：
oldpath： 用于指定被链接的源文件路径，应避免 oldpath 参数指定为软链接文件，为软链接文件创建硬链接没有意义，虽然并不会报错。
newpath： 用于指定硬链接文件路径，如果 newpath 指定的文件路径已存在，则会产生错误。
返回值： 成功返回 0；失败将返回-1，并且会设置 errno。

**创建软链接 symlink()** 

int symlink(const char *target, const char *linkpath);
首先，使用该函数需要包含头文件<unistd.h>。
函数参数和返回值含义如下：
target： 用于指定被链接的源文件路径， target 参数指定的也可以是一个软链接文件。
linkpath： 用于指定硬链接文件路径，如果 newpath 指定的文件路径已存在，则会产生错误。
返回值： 成功返回 0；失败将返回-1，并会设置 errno。
创建软链接时，并不要求 target 参数指定的文件路径已经存在，如果文件不存在，那么创建的软链接将
成为“悬空链接”。 

#### **5.7.2 读取软链接文件** 

前面给大家介绍到，软链接文件数据块中存储的是被链接文件的路径信息， 那如何读取出软链接文件中
存储的路径信息呢？大家认为使用 read 函数可以吗？答案是不可以，因为使用 read 函数之前，需要先 open打开该文件得到文件描述符，但是调用 open 打开一个链接文件本身是不会成功的，因为打开的并不是链接文件本身、而是其指向的文件，所以不能使用 read 来读取，那怎么办呢？ 可以使用系统调用 readlink 

**readlink 函数原型如下所示** 

ssize_t readlink(const char *pathname, char *buf, size_t bufsiz);
函数参数和返回值含义如下：
pathname： 需要读取的软链接文件路径。 只能是软链接文件路径，不能是其它类型文件，否则调用函
数将报错。
buf： 用于存放路径信息的缓冲区。
bufsiz： 读取大小，一般读取的大小需要大于链接文件数据块中存储的文件路径信息字节大小。
返回值： 失败将返回-1，并会设置 errno；成功将返回读取到的字节数。 

### 5.8 目录 

目录（文件夹） 在 Linux 系统也是一种文件， 是一种特殊文件，同样可以使用前面给大家介绍 open、
read 等这些系统调用以及 C 库函数对其进行操作，但是目录作为一种特殊文件，并不适合使用前面介绍的文件 I/O 方式进行读写等操作。在 Linux 系统下，会有一些专门的系统调用或 C 库函数用于对文件夹进行操作，譬如：打开、创建文件夹、删除文件夹、读取文件夹以及遍历文件夹中的文件等

#### 5.8.1 目录存储形式 

目录块当中有多个目录项（或叫目录条目） ，每一个目录项（或目录条目） 都会对应到该目录下的某一
个文件，目录项当中记录了该文件的文件名以及它的 inode 节点编号，所以通过目录的目录块便可以遍历找到该目录下的所有文件以及所对应的 inode 节点。
所以对此总结如下：
⚫ 普通文件由 inode 节点和数据块构成
⚫ 目录由 inode 节点和目录块构成 

#### 5.8.2 创建和删除目录 

使用 open 函数可以创建一个普通文件，但不能用于创建目录文件，在 Linux 系统下，提供了专门用于
创建目录 mkdir()以及删除目录 rmdir 相关的系统调用 

**mkdir 函数** 

int mkdir(const char *pathname, mode_t mode);
函数参数和返回值含义如下：
pathname： 需要创建的目录路径。
mode： 新建目录的权限设置，设置方式与 open 函数的 mode 参数一样，最终权限为（mode & ~umask）。
返回值： 成功返回 0；失败将返回-1，并会设置 errno。
pathname 参数指定的新建目录的路径，该路径名可以是相对路径，也可以是绝对路径，若指定的路径
名已经存在，则调用 mkdir()将会失败。
mode 参数指定了新目录的权限，目录拥有与普通文件相同的权限位，但是其表示的含义与普通文件却
有不同， 5.5.2 小计对此作了说明。 

**rmdir 函数** 

nt rmdir(const char *pathname);
首先，使用该函数需要包含头文件<unistd.h>。
函数参数和返回值含义如下：
pathname： 需要删除的目录对应的路径名，并且该目录必须是一个空目录，也就是该目录下只有.和..这两个目录项； pathname 指定的路径名不能是软链接文件，即使该链接文件指向了一个空目录。
返回值： 成功返回 0；失败将返回-1，并会设置 errno。 

#### 5.8.3 打开、 读取以及关闭目录 

打开、读取、关闭一个普通文件可以使用 open()、 read()、 close()，而对于目录来说，可以使用 opendir()、readdir()和 closedir()来打开、读取以及关闭目录 

**打开目录 opendir**

DIR *opendir(const char *name);
函数参数和返回值含义如下：
name： 指定需要打开的目录路径名，可以是绝对路径，也可以是相对路径。
返回值： 成功将返回指向该目录的句柄，一个 DIR 指针（其实质是一个结构体指针），其作用类似于
open函数返回的文件描述符 fd，后续对该目录的操作需要使用该 DIR指针变量；若调用失败，则返回 NULL。 

**读取目录 readdir** 

readdir()用于读取目录，获取目录下所有文件的名称以及对应 inode 号。 

struct dirent *readdir(DIR *dirp);
首先，使用该函数需要包含头文件<dirent.h>。
函数参数和返回值含义如下：
dirp： 目录句柄 DIR 指针。
返回值： 返回一个指向 struct dirent 结构体的指针， 该结构体表示 dirp 指向的目录流中的下一个目录条目。在到达目录流的末尾或发生错误时，它返回 NULL。 

Tips： “流”是从自然界中抽象出来的一种概念， 有点类似于自然界当中的水流， 在文件操作中，文件
内容数据类似池塘中存储的水， N 个字节数据被读取出来或将 N 个字节数据写入到文件中，这些数据就构成了字节流。
“流”这个概念是动态的，而不是静态的。编程当中提到这个概念，一般都是与 I/O 相关，所以也经
常叫做 I/O 流；但对于目录这种特殊文件来说， 这里将目录块中存储的数据称为目录流，存储了一个一个的目录项（目录条目） 

struct dirent 结构体内容如下所示： 

```
struct dirent {
	ino_t d_ino; /* inode 编号 */
	off_t d_off; /* not an offset; see NOTES */
	unsigned short d_reclen; /* length of this record */
	unsigned char d_type; /* type of file; not supported by all filesystem types */
	char d_name[256]; /* 文件名 */
};
```

对于 struct dirent 结构体，我们只需要关注 d_ino 和 d_name 两个字段即可，分别记录了文件的 inode 编号和文件名，其余字段并不是所有系统都支持 

每调用一次 readdir()，就会从 drip 所指向的目录流中读取下一条目录项（目录条目），并返回 struct dirent结构体指针，指向经静态分配而得的 struct dirent 类型结构，每次调用 readdir()都会覆盖该结构。 一旦遇到目录结尾或是出错， readdir()将返回 NULL，针对后一种情况，还会设置 errno 以示具体错误。那如何区别究竟是到了目录末尾还是出错了呢，可通过如下代码进行判断： 

```
error = 0;
direntp = readdir(dirp);
if (NULL == direntp) {
	if (0 != error) {
		/* 出现了错误 */
	} else {
		/* 已经到了目录末尾 */
	}
}
```

当使用 opendir()打开目录时，目录流将指向了目录列表的头部（0） ，使用 readdir()读取一条目录条目
之后，目录流将会向后移动、指向下一个目录条目。这其实跟 open()类似， 当使用 open()打开文件的时候，文件位置偏移量默认指向了文件头部，当使用 read()或 write()进行读写时，文件偏移量会自动向后移动。 

**关闭目录 closedir 函数** 

int closedir(DIR *dirp);
首先，使用该函数需要包含头文件<sys/types.h>和<dirent.h>。
函数参数和返回值含义如下：
dirp： 目录句柄。
返回值： 成功返回 0；失败将返回-1，并设置 errno。 

#### 5.8.4 进程的当前工作目录 

Linux 下的每一个进程都有自己的当前工作目录（current working directory），当前工作目录是该进程解析、搜索相对路径名的起点（不是以" / "斜杆开头的绝对路径） 。 譬如，代码中调用 open 函数打开文件时，传入的文件路径使用相对路径方式进行表示， 那么该进程解析这个相对路径名时、 会以进程的当前工作目录作为参考目录。一般情况下，运行一个进程时、其父进程的当前工作目录将被该进程所继承，成为该进程的当前工作目录。可通过 getcwd 函数来获取进程的当前工作目录，如下所示： 

char *getcwd(char *buf, size_t size);
这是一个系统调用，使用该函数之前，需要包含头文件<unistd.h>。
函数参数和返回值含义如下：
buf： getcwd()将内含当前工作目录绝对路径的字符串存放在 buf 缓冲区中。
size： 缓冲区的大小，分配的缓冲区大小必须要大于字符串长度，否则调用将会失败。
返回值： 如果调用成功将返回指向 buf 的指针，失败将返回 NULL，并设置 errno。
Tips：若传入的 buf 为 NULL，且 size 为 0，则 getcwd()内部会按需分配一个缓冲区，并将指向该缓冲区的指针作为函数的返回值，为了避免内存泄漏，调用者使用完之后必须调用 free()来释放这一缓冲区所占内存空间。 

### 5.9 删除文件 

**使用 unlink 函数删除文件** 

int unlink(const char *pathname);
使用该函数需要包含头文件<unistd.h>。
函数参数和返回值含义如下：
pathname： 需要删除的文件路径，可使用相对路径、也可使用绝对路径，如果 pathname 参数指定的文件不存在，则调用 unlink()失败。
返回值： 成功返回 0；失败将返回-1，并设置 errno。 

前面给大家介绍 link 函数，用于创建一个硬链接文件，创建硬链接时， inode 节点上的链接数就会增加；unlink()的作用与 link()相反， unlink()系统调用用于移除/删除一个硬链接 

unlink()系统调用并不会对软链接进行解引用操作，若 pathname 指定的文件为软链接文件，则删除软链
接文件本身，而非软链接所指定的文件 

**使用 remove 函数删除文件** 

int remove(const char *pathname);
使用该函数需要包含 C 库函数头文件<stdio.h>。
函数参数和返回值含义如下：
pathname： 需要删除的文件或目录路径，可以是相对路径、也可是决定路径。
返回值： 成功返回 0；失败将返回-1，并设置 errno。
pathname 参数指定的是一个非目录文件，那么 remove()去调用 unlink()，如果 pathname 参数指定的是一个目录，那么 remove()去调用 rmdir()。
与 unlink()、 rmdir()一样， remove()不对软链接进行解引用操作，若 pathname 参数指定的是一个软链接文件，则 remove()会删除链接文件本身、而非所指向的文件。 

#### 5.10 文件重命名 

本小节给大家介绍 rename()系统调用，借助于 rename()既可以对文件进行重命名，又可以将文件移至同一文件系统中的另一个目录下 

int rename(const char *oldpath, const char *newpath);
使用该函数需要包含头文件<stdio.h>。
函数参数和返回值含义如下：
oldpath： 原文件路径。
newpath： 新文件路径。
返回值： 成功返回 0；失败将返回-1，并设置 errno。 

调用 rename()会将现有的一个路径名 oldpath 重命名为 newpath 参数所指定的路径名。 rename()调用仅操作目录条目，而不移动文件数据（不改变文件 inode 编号、不移动文件数据块中存储的内容） ，重命名既不影响指向该文件的其它硬链接，也不影响已经打开该文件的进程（譬如，在重命名之前该文件已被其它进程打开了，而且还未被关闭） 

根据 oldpath、 newpath 的不同，有以下不同的情况需要进行说明：
⚫ 若 newpath 参数指定的文件或目录已经存在，则将其覆盖；
⚫ 若 newpath 和 oldpath 指向同一个文件，则不发生变化（且调用成功）。
⚫ rename()系统调用对其两个参数中的软链接均不进行解引用。如果 oldpath 是一个软链接，那么将
重命名该软链接；如果 newpath 是一个软链接，则会将其移除、被覆盖。
⚫ 如果 oldpath 指代文件，而非目录，那么就不能将 newpath 指定为一个目录的路径名。要想重命名
一个文件到某一个目录下， newpath 必须包含新的文件名。
⚫ 如果 oldpath 指代为一个目录，在这种情况下， newpath 要么不存在，要么必须指定为一个空目录。
⚫ oldpath 和 newpath 所指代的文件必须位于同一文件系统。由前面的介绍，可以得出此结论！
⚫ 不能对.（当前目录）和..（上一级目录）进行重命名。 



### 6. 字符串处理 

好在 C 语言库函数中已经给我们提供了丰富的字符串处理相关函数， 基本常见的字符串处理需求都可
以直接使用这些库函数来实现，而不需要自己编写代码，使用这些库函数可以大大减轻编程负担。这些库函数大致可以分为字符串的输入、输出、合并、修改、比较、转换、复制、搜索等几类，本章将向大家介绍这些库函数的使用方法。
本章将会讨论如下主题内容。
⚫ 字符串输入/输出；
⚫ C 库中提供的字符串处理函数；
⚫ 给应用程序传参；
⚫ 正则表达式。 

### 6.1 字符串输入/输出 

#### 6.1.1 字符串输出

常用的字符串输出函数有 putchar()、 puts()、 fputc()、 fputs()，前面我们经常使用 printf()函数来输出字符串信息，而并没有使用到 putchar()、 puts()、 fputc()、 fputs()这些函数，原因在于 printf()可以按照自己规定的格式输出字符串信息，一般称为格式化输出；而 putchar()、 puts()、 fputc()、 fputs()这些函数只能输出字符串，不能进行格式转换。所以由此可知， printf()在功能上要比 putchar()、 puts()、 fputc()、 fputs()这些函数更加强大，往往在实际编程中， printf()用的也会更多，但是 putchar()、puts()、fputc()、fputs()这些库函数相比与 printf，在使用上方便、简单。

与 printf()一样， putchar()、 puts()、 fputc()、 fputs()这些函数也是标准 I/O 函数， 属于标准 C 库函数， 所以需要包含头文件<stdio.h>，并且它们也使用 stdio 缓冲。 

**puts 函数** 

puts()函数用来向标准输出设备（屏幕、显示器）输出字符串并自行换行。 把字符串输出到标准输出设
备，将' \0 '转换为换行符' \n '。 

int puts(const char *s);
使用该函数需要包含头文件<stdio.h>。
函数参数和返回值含义如下：
s： 需要进行输出的字符串。
返回值： 成功返回一个非负数；失败将返回 EOF， EOF 其实就是-1。
使用 puts()函数连换行符' \n '都省了， 函数内部会自动在其后添加一个换行符。所以，如果只是单纯输
出字符串到标准输出设备，而不包含数字格式化转换操作，那么使用 puts()会更加方便、简洁； puts()虽然方便、简单，但也仅限于输出字符串，功能还是没有 printf()强大 。

**putchar 函数** 

putchar()函数可以把参数 c 指定的字符（一个无符号字符）输出到标准输出设备， 其输出可以是一个字
符，可以是介于 0~127 之间的一个十进制整型数（包含 0 和 127，输出其对应的 ASCII 码字符），也可以是用 char 类型定义好的一个字符型变量 

int putchar(int c);
使用该函数需要包含头文件<stdio.h>。
函数参数和返回值含义如下：
c： 需要进行输出的字符。
返回值： 出错将返回 EOF。 

**fputc 函数** 

fputc()与 putchar()类似，也用于输出参数 c 指定的字符（一个无符号字符），与 putchar()区别在于，
putchar()只能输出到标准输出设备，而 fputc()可把字符输出到指定的文件中，既可以是标准输出、标准错误设备，也可以是一个普通文件。 

int fputc(int c, FILE *stream);
使用该函数需要包含头文件<stdio.h>。
函数参数和返回值含义如下：
c： 需要进行输出的字符。
stream： 文件指针。
返回值： 成功时返回输出的字符； 出错将返回 EOF。 

**fputs 函数** 

同理， fputs()与 puts()类似，也用于输出一条字符串，与 puts()区别在于， puts()只能输出到标准输出设备，而 fputs()可把字符串输出到指定的文件中，既可以是标准输出、标准错误设备，也可以是一个普通文件。 

int fputs(const char *s, FILE *stream);
函数参数和返回值含义如下：
s： 需要输出的字符串。
stream： 文件指针。
返回值： 成功返回非负数；失败将返回 EOF。 

#### 6.1.2 字符串输入 

常用的字符串输入函数有 gets()、 getchar()、 fgetc()、 fgets()。与 printf()对应， 在 C 库函数中同样也提供了格式化输入函数 scanf()。 scanf()与 gets()、 getchar()、 fgetc()、 fgets()这些函数相比，在功能上确实有它的优势，但是在使用上不如它们方便、简单、更易于使用。
与 scanf()一样， gets()、 getchar()、 fgetc()、 fgets()这些函数也是标准 I/O 函数， 属于标准 C 库函数， 所以需要包含头文件<stdio.h>，并且它们也使用 stdio 缓冲 

**gets 函数** 

gets()函数用于从标准输入设备（譬如键盘）中获取用户输入的字符串 

char *gets(char *s); 

使用该函数需要包含头文件<stdio.h>。
函数参数和返回值含义如下：
s： 指向字符数组的指针， 用于存储字符串。
返回值： 如果成功， 该函数返回指向 s 的指针； 如果发生错误或者到达末尾时还未读取任何字符，则返
回 NULL 

用户从键盘输入的字符串数据首先会存放在一个输入缓冲区中， gets()函数会从输入缓冲区中读取字符
串存储到字符指针变量 s 所指向的内存空间，当从输入缓冲区中读走字符后，相应的字符便不存在于缓冲区了。
输入的字符串中就算是有空格也可以直接输入，字符串输入完成之后按回车即可， gets()函数不检查缓
冲区溢出。 

出现警告信息，其实是建议我们不要使用 gets()函数，因为程序中使用 gets()函数是非常不安全的，
可能会出现 bug、出现不可靠性， gets()在某些意外情况下会导致程序陷入不可控状态，所以一般建议大家不要使用这个函数，可以使用后面将给大家介绍的 fgets()代替。 

- **gets()与 scanf()的区别** 

gets()除了在功能上不及 scanf 之外，它们在一些细节上也存在着不同：
⚫ gets()函数不仅比 scanf 简洁，而且，就算输入的字符串中有空格也可以， 因为 gets()函数允许输入
的字符串带有空格、制表符，输入的空格和制表符也是字符串的一部分，仅以回车换行符作为字符
串的分割符； 而对于 scanf 以%s 格式输入的时候， 空格、换行符、 TAB 制表符等都是作为字符串
分割符存在， 即分隔符前后是两个字符串， 读取字符串时并不会将分隔符读取出来作为字符串的组
成部分， 一个%s 只能读取一个字符串，若要多去多个字符串，则需要使用多个%s、并且需要使用
多个字符数组存储。
⚫ gets()会将回车换行符从输入缓冲区中取出来，然后将其丢弃，所以使用 gets()读走缓冲区中的字符
串数据之后，缓冲区中将不会遗留下回车换行符；而对于 scanf()来说，使用 scanf()读走缓冲区中
的字符串数据时，并不会将分隔符（空格、 TAB 制表符、 回车换行符等） 读走将其丢弃，所以使
用 scanf()读走缓冲区中的字符串数据之后，缓冲区中依然还存在用户输入的分隔符。 

**TIPS: scanf 用的是%c 格式，而不是%s， 对于%c 读入时，空格、换行符、TAB 这些都是正常字符。** 

**getchar 函数** 

getchar()函数用于从标准输入设备中读取一个字符（一个无符号字符）， 

int getchar(void);
使用该函数需要包含头文件<stdio.h>。
函数参数和返回值含义如下：
无需传参。
返回值： 该函数以无符号 char 强制转换为 int 的形式返回读取的字符，如果到达文件末尾或发生读错
误，则返回 EOF。 

同样 getchar()函数也是从输入缓冲区读取字符数据，但只读取一个字符，包括空格、 TAB 制表符、换
行回车符等。 

getchar()只从输入缓冲区中读取一个字符，与 scanf 以%c 格式读取一样，空格、 TAB 制表符、回车符都将是正常的字符。即使输入了多个字符，但 getchar()仅读取一个字符。 

**fgets 函数** 

fgets()与 gets()一样用于获取输入的字符串 

char *fgets(char *s, int size, FILE *stream);
使用该函数需要包含头文件<stdio.h>。
函数参数和返回值含义如下：
s： 指向字符数组的指针，用于存储字符串。
size： 这是要读取的最大字符数。
stream： 文件指针 

fgets()与 gets()的区别主要是三点：
⚫ gets()只能从标准输入设备中获取输入字符串，而 fgets()既可以从标准输入设备获取字符串、也可
以从一个普通文件中获取输入字符串。
⚫ fgets()可以设置获取字符串的最大字符数。
⚫ gets()会将缓冲区中的换行符'\n'读取出来、将其丢弃、将'\n'替换为字符串结束符'\0'； fgets()也会将
缓冲区中的换行符读取出来，但并不丢弃，而是作为字符串组成字符存在，读取完成之后自动在最
后添加字符串结束字符'\0'。
其它方面与 gets()函数一样，包括前面给大家所介绍的与 scanf(%s)在一些细节方面的区别。 

**fgetc 函数**

fgetc()与 getchar()一样，用于读取一个输入字符 

int fgetc(FILE *stream);
使用该函数需要包含头文件<stdio.h>。
函数参数和返回值含义如下：
stream： 文件指针。 

返回值： 该函数以无符号 char 强制转换为 int 的形式返回读取的字符，如果到达文件末尾或发生读错
误，则返回 EOF。
fgetc()与 getchar()的区别在于， fgetc 可以指定输入字符的文件，既可以从标准输入设备输入字符，也可以从一个普通文件中输入字符，其它方面与 getchar 函数相同 

#### 6.2  字符串长度 

C 语言函数库中提供了一个用于计算字符串长度的函数 strlen()，其函数原型如下所示：

size_t strlen(const char *s);
使用该函数需要包含头文件<string.h>。
函数参数和返回值含义如下：
s： 需要进行长度计算的字符串，字符串必须包含结束字符' \0 '。
返回值： 返回字符串长度（以字节为单位），字符串结束字符' \0 '不计算在内。

**sizeof 和 strlen 的区别**  

在程序当中，我们通常也会使用 sizeof 来计算长度，那 strlen 和 sizeof 有什么区别呢？
⚫ sizeof 是 C 语言内置的操作符关键字，而 strlen 是 C 语言库函数；
⚫ sizeof 仅用于计算数据类型的大小或者变量的大小，而 strlen 只能以结尾为' \0 '的字符串作为参数；
⚫ 编译器在编译时就计算出了 sizeof 的结果，而 strlen 必须在运行时才能计算出来；
⚫ sizeof 计算数据类型或变量会占用内存的大小， strlen 计算字符串实际长度 

#### 6.3 字符串拼接 

C 语言函数库中提供了 strcat()函数或 strncat()函数用于将两个字符串连接（拼接）起来， strcat 函数原
型如下所示：

**strcat 函数**

char *strcat(char *dest, const char *src);
使用该函数需要包含头文件<string.h>。
函数参数和返回值含义如下：
dest： 目标字符串。
src： 源字符串。
返回值： 返回指向目标字符串 dest 的指针。 

strcat()函数会把 src 所指向的字符串追加到 dest 所指向的字符串末尾，所以必须要保证 dest 有足够的存储空间来容纳两个字符串，否则会导致溢出错误； dest 末尾的' \0 '结束字符会被覆盖， src 末尾的结束字符'\0 '会一起被复制过去，最终的字符串只有一个' \0 '。 

**strncat 函数** 

trncat()与 strcat()的区别在于， strncat 可以指定源字符串追加到目标字符串的字符数量 

char *strncat(char *dest, const char *src, size_t n);
函数参数和返回值含义如下：
dest： 目标字符串。
src： 源字符串。
n： 要追加的最大字符数。
返回值： 返回指向目标字符串 dest 的指针。
如果源字符串 src 包含 n 个或更多个字符， 则 strncat()将 n+1 个字节追加到 dest 目标字符串（src 中的 n个字符加上结束字符' \0 '）。 

### 6.4 字符串拷贝 

语言函数库中提供了 strcpy()函数和 strncpy()函数用于实现字符串拷贝 

char *strcpy(char *dest, const char *src);
函数参数和返回值含义如下： 

dest： 目标字符串。
src： 源字符串。
返回值： 返回指向目标字符串 dest 的指针。
strcpy()会把 src（必须包含结束字符' \0 '） 指向的字符串复制（包括字符串结束字符' \0 '） 到 dest，所以必须保证 dest 指向的内存空间足够大，能够容纳下 src 字符串，否则会导致溢出错误 



**strncpy()与 strcpy()的区别在于， strncpy()可以指定从源字符串 src 复制到目标字符串 dest 的字符数量** 

### 6.5 内存填充 

在编程中，经常需要将某一块内存中的数据全部设置为指定的值，譬如在定义数组、结构体这种类型变
量时，通常需要对其进行初始化操作，而初始化操作一般都是将其占用的内存空间全部填充为 0。 

**memset 函数** 

memset()函数用于将某一块内存的数据全部设置为指定的值，其函数原型如下所示：
#include <string.h>
void *memset(void *s, int c, size_t n);
使用该函数需要包含头文件<string.h>。
函数参数和返回值含义如下：
s： 需要进行数据填充的内存空间起始地址。
c： 要被设置的值，该值以 int 类型传递。
n： 填充的字节数。
返回值： 返回指向内存空间 s 的指针。
参数 c 虽然是以 int 类型传递，但 memset()函数在填充内存块时是使用该值的无符号字符形式，也就是
函数内部会将该值转换为 unsigned char 类型的数据，以字节为单位进行数据填充。 



**bzero 函数**
bzero()函数用于将一段内存空间中的数据全部设置为 0 

### 6.6 字符串比较 

C 语言函数库提供了用于字符串比较的函数 strcmp()和 strncmp() 

**strcmp 函数** 

int strcmp(const char *s1, const char *s2);
函数参数和返回值含义如下：
s1： 进行比较的字符串 1。
s2： 进行比较的字符串 2。
返回值：
⚫ 如果返回值小于 0，则表示 str1 小于 str2
⚫ 如果返回值大于 0，则表示 str1 大于 str2
⚫ 如果返回值等于 0，则表示字符串 str1 等于字符串 str2 

trcmp 进行字符串比较，主要是通过比较字符串中的字符对应的 ASCII 码值， strcmp 会根据 ASCII 编
码依次比较 str1 和 str2 的每一个字符，直到出现了不同的字符，或者某一字符串已经到达末尾（遇见了字符串结束字符' \0 '）。 

**strncmp 函数** 

strncmp()与 strcmp()函数一样，也用于对字符串进行比较操作，但最多比较前 n 个字符 

int strncmp(const char *s1, const char *s2, size_t n);
函数参数和返回值含义如下：
s1： 参与比较的第一个字符串。
s2： 参与比较的第二个字符串。
n： 最多比较前 n 个字符。
返回值： 返回值含义与 strcmp()函数相同。 

### 6.7 字符串查找 

字符串查找在平时的编程当中也是一种很常见的操作，譬如从一个给定的字符串当中查找某一个字符
或者一个字符串，并获取它的位置。 C 语言函数库中也提供了一些用于字符串查找的函数，包括 strchr()、strrchr()、 strstr()、 strpbrk()、 index()以及 rindex()等。 

**strchr 函数** 

使用 strchr()函数可以查找到给定字符串当中的某一个字符 

char *strchr(const char *s, int c);
函数参数和返回值含义如下：
s： 给定的目标字符串。
c： 需要查找的字符。
返回值： 返回字符 c 第一次在字符串 s 中出现的位置，如果未找到字符 c，则返回 NULL。
字符串结束字符' \0 '也将作为字符串的一部分， 因此，如果将参数 c 指定为' \0 '，则函数将返回指向结
束字符的指针。 strchr 函数在字符串 s 中从前到后（或者称为从左到右）查找字符 c，找到字符 c 第一次出现的位置就返回，返回值指向这个位置，如果找不到字符 c 就返回 NULL。 

**strrchr 函数**
strrchr()与 strchr()函数一样，它同样表示在字符串中查找某一个字符，返回字符第一次在字符串中出现
的位置，如果没找到该字符，则返回值 NULL，但两者唯一不同的是， strrchr()函数在字符串中是从后到前（或者称为从右向左）查找字符，找到字符第一次出现的位置就返回，返回值指向这个位置 

**strstr 函数**
与 strchr()函数不同的是，strstr()可在给定的字符串 haystack 中查找第一次出现子字符串 needle 的位置，不包含结束字符' \0 '， 

char *strstr(const char *haystack, const char *needle);
函数参数和返回值含义如下：
haystack： 目标字符串。
needle： 需要查找的子字符串。
返回值： 如果目标字符串 haystack 中包含了子字符串 needle，则返回该字符串首次出现的位置；如果未能找到子字符串 needle，则返回 NULL 

### **6.8 字符串与数字互转** 

在编程中，经常会需要将数字组成的字符串转换为相应的数字、或者将数字转换为字符串，在 C 函数
库中同样也提供了相应的函数， 本小节就向大家介绍这些函数的用法 

#### 6.8.1 字符串转整形数据 

C 函数库中提供了一系列函数用于实现将一个字符串转为整形数据，主要包括 atoi()、 atol()、 atoll()以及
strtol()、 strtoll()、 strtoul()、 strtoull()等， 它们之间的区别主要包括以下两个方面：
⚫ 数据类型（int、 long int、 unsigned long 等）。
⚫ 不同进制方式表示的数字字符串（八进制、十六进制、十进制）。 

**atoi、 atol、 atoll 函数** 

atoi()、 atol()、 atoll()三个函数可用于将字符串分别转换为 int、 long int 以及 long long 类型的数据， 它们
的函数原型如下：
int atoi(const char *nptr);
long atol(const char *nptr);
long long atoll(const char *nptr);
使用这些函数需要包含头文件<stdlib.h>。
函数参数和返回值含义如下：
nptr： 需要进行转换的字符串。
返回值： 分别返回转换之后得到的 int 类型数据、 long int 类型数据以及 long long 类型数据。
目标字符串 nptr 中可以包含非数字字符， 转换时跳过前面的空格字符（如果目标字符串开头存在空格
字符） ，直到遇上数字字符或正负符号才开始做转换，而再遇到非数字或字符串结束时(' /0 ')才结束转换，并将结果返回。
使用 atoi()、 atol()、 atoll()函数只能转换十进制表示的数字字符串，即 0~9。 

**strtol、 strtoll 函数** 

trtol()、 strtoll()两个函数可分别将字符串转为 long int 类型数据和 long long ing 类型数据，与 atol()、
atoll()之间的区别在于， strtol()、 strtoll()可以实现将多种不同进制数（譬如二进制表示的数字字符串、八进制表示的数字字符串、十六进制表示的数数字符串） 表示的字符串转换为整形数据， 

long int strtol(const char *nptr, char **endptr, int base);
long long int strtoll(const char *nptr, char **endptr, int base);
使用这两个函数需要包含头文件<stdlib.h>。
函数参数和返回值含义如下：
nptr： 需要进行转换的目标字符串。
endptr： char  类型的指针， 如果 endptr 不为 NULL，则 strtol()或 strtoll()会将字符串中第一个无效字
符的地址存储在*endptr 中。如果根本没有数字， strtol()或 strtoll()会将 nptr 的原始值存储在*endptr 中（并返
回 0）。 也可将参数 endptr 设置为 NULL，表示不接收相应信息。
base： 数字基数， 参数 base 必须介于 2 和 36（包含）之间，或者是特殊值 0。 参数 base 决定了字符串转换为整数时合法字符的取值范围，譬如，当 base=2 时，合法字符为' 0 '、 ' 1 '（表示是一个二进制表示的数字字符串） ；当 base=8 时，合法字符为' 0 '、 ' 1 '、 ' 2 '、 ' 3 '……' 7 '（表示是一个八进制表示的数字字符串） ；当 base=16 时，合法字符为' 0 ' 、 ' 1 '、 ' 2 '、 ' 3 '……' 9 '、 ' a '……' f '（表示是一个十六进制表示的数字字符串） ；当 base 大于 10 的时候， ' a '代表 10、 ' b '代表 11、 ' c '代表 12，依次类推， ' z '代表 35（不区分大小写） 。
返回值： 分别返回转换之后得到的 long int 类型数据以及 long long int 类型数据。
需要进行转换的目标字符串可以以任意数量的空格或者 0 开头， 转换时跳过前面的空格字符，直到遇
上数字字符或正负符号（' + '或' - '） 才开始做转换，而再遇到非数字或字符串结束时(' /0 ')才结束转换，并将结果返回。 

在 base=0 的情况下， 如果字符串包含一个了“0x”前缀， 表示该数字将以 16 为基数； 如果包含的是
“0”前缀，表示该数字将以 8 为基数。
当 base=16 时，字符串可以使用“0x”前缀 

**strtoul、 strtoull 函数**

这两个函数使用方法与 strtol()、strtoll()一样，区别在于返回值的类型不同，strtoul()返回值类型是 unsigned
long int， strtoull()返回值类型是 unsigned long long int 

#### **6.8.2 字符串转浮点型数据** 

C 函数库中用于字符串转浮点型数据的函数有 atof()、 strtod()、 strtof()、 strtold() 

**atof 函数**

atof()用于将字符串转换为一个 double 类型的浮点数据，函数原型如下所示：

double atof(const char *nptr);
使用该函数需要包含头文件<stdlib.h>。
函数参数和返回值含义如下：
nptr： 需要进行转换的字符串。
返回值： 返回转换得到的 double 类型数据。 

**strtod、 strtof、 strtold 函数** 

trtof()、 strtod()以及 strtold()三个库函数可分别将字符串转换为 float 类型数据、 double 类型数据、 long double 类型数据 

double strtod(const char *nptr, char **endptr);
float strtof(const char *nptr, char **endptr);
long double strtold(const char *nptr, char **endptr);
使用这些函数需要包含头文件<stdlib.h>。
函数参数与 strtol()含义相同，但是少了 base 参数。 

#### **6.8.3 数字转字符串** 

数字转换为字符串推荐大家使用前面介绍的格式化 IO 相关库函数，譬如使用 printf()将数字转字符串、
并将其输出到标准输出设备或者使用 sprintf()或 snprintf()将数字转换为字符串并存储在缓冲区中，具体的使用方法 



## 7.系统信息与系统资源 

在应用程序当中，有时往往需要去获取到一些系统相关的信息，譬如时间、日期、以及其它一些系统相
关信息，本章将向大家介绍如何通过 Linux 系统调用或 C 库函数获取系统信息， 譬如获取系统时间、日期
以及设置系统时间、日期等；除此之外，还会向大家介绍 Linux 系统下的/proc 虚拟文件系统，包括/proc 文
件系统是什么以及如何从/proc 文件系统中读取系统、进程有关信息。
除了介绍系统信息内容外， 本章还会向大家介绍有关系统资源的使用，譬如系统内存资源的申请与使用
等。好了，废话不多少，开始本章内容的学习吧！
⚫ 用于获取系统相关信息的函数；
⚫ 时间、日期；
⚫ 进程时间；
⚫ 使程序进入休眠；
⚫ 在堆中申请内存；
⚫ proc 文件系统介绍；
⚫ 定时器 

### 7.1 系统信息 

#### 7.1.1 系统标识 uname 

系统调用 uname()用于获取有关当前操作系统内核的名称和信息 

int uname(struct utsname *buf);
使用该函数需要包含头文件<sys/utsname.h>。
函数参数和返回值含义如下：
buf： struct utsname 结构体类型指针， 指向一个 struct utsname 结构体类型对象。
返回值： 成功返回 0；失败将返回-1，并设置 errno。
uname()函数用法非常简单，先定义一个 struct utsname 结构体变量，调用 uname()函数时传入变量的地址即可 

struct utsname 结构体如下所示： 

```
struct utsname {
	char sysname[]; /* 当前操作系统的名称 */
	char nodename[]; /* 网络上的名称（主机名） */
	char release[]; /* 操作系统内核版本 */
	char version[]; /* 操作系统发行版本 */
	char machine[]; /* 硬件架构类型 */
	#ifdef _GNU_SOURCE
	char domainname[];/* 当前域名 */
	#endif
};
```

可以看到， struct utsname 结构体中的所有成员变量都是字符数组， 所以获取到的信息都是字符串 



#### 7.1.2 sysinfo 函数 

sysinfo 系统调用可用于获取一些系统统计信息，其函数原型如下所示：
#include <sys/sysinfo.h>
int sysinfo(struct sysinfo *info);
函数参数和返回值含义如下：
info： struct sysinfo 结构体类型指针，指向一个 struct sysinfo 结构体类型对象。
返回值： 成功返回 0；失败将返回-1，并设置 errno。
同样 sysinfo()函数用法也非常简单，先定义一个 struct sysinfo 结构体变量，调用 sysinfo()函数时传入变量的地址即可 

struct sysinfo 结构体如下所示： 

```
struct sysinfo {
    long uptime; /* 自系统启动之后所经过的时间（以秒为单位） */
    unsigned long loads[3]; /* 1, 5, and 15 minute load averages */
    unsigned long totalram; /* 总的可用内存大小 */
    unsigned long freeram; /* 还未被使用的内存大小 */
    unsigned long sharedram; /* Amount of shared memory */
    unsigned long bufferram; /* Memory used by buffers */
    unsigned long totalswap; /* Total swap space size */
    unsigned long freeswap; /* swap space still available */
    unsigned short procs; /* 系统当前进程数量 */
    unsigned long totalhigh; /* Total high memory size */
    unsigned long freehigh; /* Available high memory size */
    unsigned int mem_unit; /* 内存单元大小（以字节为单位） */
    char _f[20-2*sizeof(long)-sizeof(int)]; /* Padding to 64 bytes */
};
```



#### 7.1.3 gethostname 函数 

函数可用于单独获取 Linux 系统主机名， 与 struct utsname 数据结构体中的 nodename 变量一样， 

nt gethostname(char *name, size_t len);
使用此函数需要包含头文件<unistd.h>。
函数参数和返回值含义如下：
name： 指向用于存放主机名字符串的缓冲区。
len： 缓冲区长度。
返回值： 成功返回 0,；失败将返回-1，并会设置 errno。

 

#### 7.1.4 sysconf()函数 

sysconf()函数是一个库函数，可在运行时获取系统的一些配置信息，譬如页大小（page size）、主机名
的最大长度、进程可以打开的最大文件数、 每个用户 ID 的最大并发进程数等 

ong sysconf(int name);
使用该函数需要包含头文件<unistd.h>。
调用 sysconf()函数获取系统的配置信息， 参数 name 指定了要获取哪个配置信息，参数 name 可取以下任何一个值（都是宏定义， 可通过 man 手册查询）  

⚫ _SC_ARG_MAX： exec 族函数的参数的最大长度， exec 族函数后面会介绍，这里先不管！
⚫ _SC_CHILD_MAX： 每个用户的最大并发进程数，也就是同一个用户可以同时运行的最大进程数。
⚫ _SC_HOST_NAME_MAX： 主机名的最大长度。
⚫ _SC_LOGIN_NAME_MAX： 登录名的最大长度。
⚫ _SC_CLK_TCK： 每秒时钟滴答数，也就是系统节拍率。
⚫ _SC_OPEN_MAX： 一个进程可以打开的最大文件数。
⚫ _SC_PAGESIZE： 系统页大小（page size）。
⚫ _SC_TTY_NAME_MAX： 终端设备名称的最大长度。 

若指定的参数 name 为无效值，则 sysconf()函数返回-1，并会将 errno 设置为 EINVAL。否则返回的值
便是对应的配置值。注意，返回值是一个 long 类型的数据 

使用示例
获取每个用户的最大并发进程数、系统节拍率和系统页大小 

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main(void)
{
    printf("每个用户的最大并发进程数: %ld\n", sysconf(_SC_CHILD_MAX));
    printf("系统节拍率: %ld\n", sysconf(_SC_CLK_TCK));
    printf("系统页大小: %ld\n", sysconf(_SC_PAGESIZE));
    exit(0);
}
```

### 7.2 时间、日期 

#### 7.2.1 时间的概念 

**GMT 时间** 

GMT（Greenwich Mean Time） 中文全称是格林威治标准时间 

譬如 GMT 12:00 就是
指英国伦敦的格林威治皇家天文台当地的中午 12:00，与我国的标准时间北京时间（东八区）相差 8 个小时，即早八个小时，所以 GMT 12:00 对应的北京时间是 20:00。 

**UTC 时间**
UTC（Coordinated Universal Time）指的是世界协调时间（又称世界标准时间、世界统一时间）， 是经过平均太阳时(以格林威治时间 GMT 为准)、地轴运动修正后的新时标以及以「秒」为单位的国际原子时所综合精算而成的时间，计算过程相当严谨精密，因此若以「世界标准时间」的角度来说， UTC 比 GMT 来得更加精准。
GMT 与 UTC 这两者几乎是同一概念，它们都是指格林威治标准时间，也就是国际标准时间，只不过
UTC 时间比 GMT 时间更加精准，所以在我们的编程当中不用刻意去区分它们之间的区别 

在 Ubuntu 系统下， 可以使用"date -u"命令查看到当前的 UTC 时间 

在 Ubuntu 系统下，可以使用 date 命令查看系统当前的本地时间 

#### 7.2.2 Linux 系统中的时间 

**点时间和段时间** 

通常描述时间有两种方式：点时间和段时间；点时间顾名思义指的是某一个时间点，譬如当前时间是
2021 年 2 月 22 日星期一 11:12 分 35 秒，所以这里指的就是某一个时间点；而对于段时间来说，顾名思义指的是某一个时间段，譬如早上 8:00 到中午 12:00 这段时间 

**实时时钟 RTC** 

操作系统中一般会有两个时钟，一个系统时钟（system clock），一个实时时钟（Real time clock），也叫 RTC；系统时钟由系统启动之后由内核来维护， 譬如使用 date 命令查看到的就是系统时钟， 所以在系统关机情况下是不存在的；而实时时钟一般由 RTC 时钟芯片提供， RTC 芯片有相应的电池为其供电，以保证系统在关机情况下 RTC 能够继续工作、继续计时。

#### 7.2.3获取时间 time/gettimeofday 

**time 函数**
系统调用 time()用于获取当前时间，以秒为单位，返回得到的值是自 1970-01-01 00:00:00 +0000 (UTC)
以来的秒数 

time_t time(time_t *tloc);
使用该函数需要包含头文件<time.h>。
函数参数和返回值含义如下：
tloc： 如果 tloc 参数不是 NULL，则返回值也存储在 tloc 指向的内存中。 

返回值： 成功则返回自 1970-01-01 00:00:00 +0000 (UTC)以来的时间值（以秒为单位） ；失败则返回-1，并会设置 errno。
所以由此可知， time 函数获取得到的是一个时间段，也就是从 1970-01-01 00:00:00 +0000 (UTC)到现在这段时间所经过的秒数，所以你要计算现在这个时间点，只需要使用 time()得到的秒数加 1970-01-01 00:00:00即可 

**gettimeofday 函数** 

ime()获取到的时间只能精确到秒，如果想要获取更加精确的时间可以使用系统调用 gettimeofday 来实
现， gettimeofday()函数提供微秒级时间精度 

int gettimeofday(struct timeval *tv, struct timezone *tz);
使用该函数需要包含头文件<sys/time.h>。
函数参数和返回值含义如下： 

tv： 参数 tv 是一个 struct timeval 结构体指针变量， struct timeval 结构体在前面章节内容中已经给大家介
绍过，具体参考示例代码 5.6.3。
tz： 参数 tz 是个历史产物，早期实现用其来获取系统的时区信息，目前已遭废弃，在调用 gettimeofday()
函数时应将参数 tz 设置为 NULL。
返回值： 成功返回 0；失败将返回-1，并设置 errno。
获取得到的时间值存储在参数 tv 所指向的 struct timeval 结构体变量中，该结构体包含了两个成员变量
tv_sec 和 tv_usec，分别用于表示秒和微秒，所以获取得到的时间值就是 tv_sec（秒） +tv_usec（微秒） ，同样获取得到的秒数与 time()函数一样，也是自 1970-01-01 00:00:00 +0000 (UTC)到现在这段时间所经过的秒数， 也就是日历时间， 所以由此可知 time()返回得到的值和函数 gettimeofday()所返回的 tv 参数中 tv_sec 字段的数值相同 

#### 7.2.4 时间转换函数 

通过 time()或 gettimeofday()函数可以获取到当前时间点相对于 1970-01-01 00:00:00 +0000 (UTC)这个时间点所经过时间（日历时间） ，所以获取得到的是一个时间段的长度，但是这并不利于我们查看当前时间 ，这个结果对于我们来说非常不友好，那么本小节将向大家介绍一些系统调用或 C 库函数，通过这些 API 可以将 time()或 gettimeofday()函数获取到的秒数转换为利于查看和理解的形式。 

**ctime 函数** 

ctime()是一个 C 库函数， 可以将日历时间转换为可打印输出的字符串形式 

char *ctime(const time_t *timep);
char *ctime_r(const time_t *timep, char *buf);
使用该函数需要包含头文件<time.h>。
函数参数和返回值含义如下：
timep： time_t 时间变量指针。
返回值： 成功将返回一个 char *类型指针，指向转换后得到的字符串；失败将返回 NULL。
所以由此可知，使用 ctime 函数非常简单，只需将 time_t 时间变量的指针传入即可，调用成功便可返回
字符串指针，拿到字符串指针之后，可以使用 printf 将其打印输出。但是 ctime()是一个不可重入函数， 存在一些安全上面的隐患， ctime_r()是 ctime()的可重入版本，一般推荐大家使用可重入函数 ctime_r()，可重入函数 ctime_r()多了一个参数 buf，也就是缓冲区首地址，所以 ctime_r()函数需要调用者提供用于存放字符串的缓冲区。 

ips：关于可重入函数与不可重入函数将会在后面章节内容中进行介绍，这里暂时先不去管这个问题，
在 Linux 系统中，有一些系统调用或 C 库函数提供了可重入版本与不可重入版本的函数接口，可重入版本函数所对应的函数名一般都会有一个" _r "后缀来表明它是一个可重入函数。 

ctime （或 ctime_r）转换得到的时间是计算机所在地对应的本地时间（譬如在中国对应的便是北京时间），并不是 UTC 时间，接下来编写一段简单地代码进行测试。 

**localtime 函数** 

localtime()函数可以把 time()或 gettimeofday()得到的秒数（time_t 时间或日历时间） 变成一个 struct tm结构体所表示的时间， 该时间对应的是本地时间。 

struct tm *localtime(const time_t *timep);
struct tm *localtime_r(const time_t *timep, struct tm *result);
使用该函数需要包含头文件<time.h>， localtime()的可重入版本为 localtime_r()。
函数参数和返回值含义如下：
timep： 需要进行转换的 time_t 时间变量对应的指针，可通过 time()或 gettimeofday()获取得到。
result： 是一个 struct tm 结构体类型指针， 稍后给大家介绍 struct tm 结构体，参数 result 是可重入函数
localtime_r()需要额外提供的参数。
返回值： 对于不可重入版本 localtime()来说，成功则返回一个有效的 struct tm 结构体指针，而对于可重入版本 localtime_r()来说， 成功执行情况下，返回值将会等于参数 result；失败则返回 NULL。
使用不可重入函数 localtime()并不需要调用者提供 struct tm 变量，而是它会直接返回出来一个 struct tm结构体指针，然后直接通过该指针访问里边的成员变量即可！虽然很方便，但是存在一些安全隐患，所以一般不推荐使用不可重入版本。
使用可重入版本 localtime_r()调用者需要自己定义 struct tm 结构体变量、并将该变量指针赋值给参数
result，在函数内部会对该结构体变量进行赋值操作。 

struct tm 结构体如下所示： 

```
struct tm {
    int tm_sec; /* 秒(0-60) */
    int tm_min; /* 分(0-59) */
    int tm_hour; /* 时(0-23) */
    int tm_mday; /* 日(1-31) */
    int tm_mon; /* 月(0-11) */
    int tm_year; /* 年(这个值表示的是自 1900 年到现在经过的年数) */
    int tm_wday; /* 星期(0-6, 星期日 Sunday = 0、星期一=1…) */
    int tm_yday; /* 一年里的第几天(0-365, 1 Jan = 0) */
    int tm_isdst; /* 夏令时 */
};
```

从 struct tm 结构体内容可知，该结构体中包含了年月日时分秒星期等信息， 使用 localtime/localtime_r()便可以将 time_t 时间总秒数分解成了各个独立的时间信息， 易于我们查看和理解。 

**gmtime 函数** 

gmtime()函数也可以把 time_t 时间变成一个 struct tm 结构体所表示的时间，与 localtime()所不同的是，gmtime()函数所得到的是 UTC 国际标准时间，并不是计算机的本地时间，这是它们之间的唯一区别。gmtime()

**mktime 函数** 

mktime()函数与 localtime()函数相反， mktime()可以将使用 struct tm 结构体表示的分解时间转换为 time_t时间（日历时间）  

time_t mktime(struct tm *tm);
使用该函数需要包含头文件<time.h>。
函数参数和返回值含义如下：
tm： 需要进行转换的 struct tm 结构体变量对应的指针。
返回值： 成功返回转换得到 time_t 时间值；失败返回-1。 

**asctime 函数** 

asctime()函数与 ctime()函数的作用一样，也可将时间转换为可打印输出的字符串形式，与 ctime()函数
的区别在于， ctime()是将 time_t 时间转换为固定格式字符串、而 asctime()则是将 struct tm 表示的分解时间转换为固定格式的字符串。

char *asctime(const struct tm *tm);
char *asctime_r(const struct tm *tm, char *buf);
使用该函数需要包含头文件<time.h>。
函数参数和返回值含义如下：
tm： 需要进行转换的 struct tm 表示的时间。
buf： 可重入版本函数 asctime_r 需要额外提供的参数 buf，指向一个缓冲区，用于存放转换得到的字符
串。
返回值： 转换失败将返回 NULL；成功将返回一个 char *类型指针，指向转换后得到的时间字符串，对
于 asctime_r 函数来说，返回值就等于参数 buf。
测试  

**strftime 函数** 

除了 asctime()函数之外，这里再给大家介绍一个 C 库函数 strftime()，此函数也可以将一个 struct tm 变量表示的分解时间转换为为格式化字符串，并且在功能上比 asctime()和 ctime()更加强大，它可以根据自己的喜好自定义时间的显示格式，而 asctime()和 ctime()转换得到的字符串时间格式的固定的。

size_t strftime(char *s, size_t max, const char *format, const struct tm *tm);
使用该函数需要包含头文件<time.h>。
函数参数和返回值含义如下：
s： 指向一个缓存区的指针，该缓冲区用于存放生成的字符串。
max： 字符串的最大字节数。
format： 这是一个用字符串表示的字段， 包含了普通字符和特殊格式说明符，可以是这两种字符的任意
组合。 特殊格式说明符将会被替换为 struct tm 结构体对象所指时间的相应值

strftime 函数的特殊格式说明符还是比较多的，不用去记它，需要用的时候再去查即可！ 

通过上表可知，譬如我要想输出"2021-01-14 16:30:25<PM> January Thursday"这样一种形式表示的时间日期，那么就可以这样来设置 format 参数： 

```
"%Y-%m-%d %H:%M:%S<%p> %B %A"
```

tm： 指向 struct tm 结构体对象的指针。
返回值： 如果转换得到的目标字符串不超过最大字节数（也就是 max），则返回放置到 s 数组中的字节
数；如果超过了最大字节数，则返回 0。 

测试 

```
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int main(void)
{
    struct tm local_t;
    char tm_str[100] = {0};
    time_t sec;
    /* 获取时间 */
    sec = time(NULL);
    if (-1 == sec) {
        perror("time error");
        exit(-1);
    }
    localtime_r(&sec, &local_t);
    strftime(tm_str, sizeof(tm_str), "%Y-%m-%d %A %H:%M:%S", &local_t);
    printf("本地时间: %s\n", tm_str);
    exit(0);
}
```

#### 7.2.5设置时间 settimeofday 

使用 settimeofday()函数可以设置时间， 也就是设置系统的本地时间 

settimeofday(const struct timeval *tv, const struct timezone *tz);
首先使用该函数需要包含头文件<sys/time.h>。
函数参数和返回值含义如下：
tv： 参数 tv 是一个 struct timeval 结构体指针变量， struct timeval 结构体在前面章节内容中已经给大家介绍了，需要设置的时间便通过参数 tv 指向的 struct timeval 结构体变量传递进去。
tz： 参数 tz 是个历史产物，早期实现用其来设置系统的时区信息，目前已遭废弃，在调用 settimeofday()
函数时应将参数 tz 设置为 NULL。
返回值： 成功返回 0；失败将返回-1，并设置 errno。
使用 settimeofday 设置系统时间时内核会进行权限检查，只有超级用户（root）才可以设置系统时间，
普通用户将无操作权限 

### 7.3 进程时间 

进程时间指的是进程从创建后（也就是程序运行后）到目前为止这段时间内使用 CPU 资源的时间总数，
出于记录的目的，内核把 CPU 时间（进程时间） 分为以下两个部分：
⚫ 用户 CPU 时间：进程在用户空间（用户态）下运行所花费的 CPU 时间。有时也成为虚拟时间（virtual
time）。
⚫ 系统 CPU 时间：进程在内核空间（内核态）下运行所花费的 CPU 时间。这是内核执行系统调用或
代表进程执行的其它任务（譬如，服务页错误）所花费的时间。
一般来说，进程时间指的是用户 CPU 时间和系统 CPU 时间的总和，也就是总的 CPU 时间。 

Tips：进程时间不等于程序的整个生命周期所消耗的时间， 如果进程一直处于休眠状态（进程被挂起、
不会得到系统调度），那么它并不会使用 CPU 资源，所以休眠的这段时间并不计算在进程时间中。 

#### 7.3.1 times 函数 

times()函数用于获取当前进程时间，其函数原型如下所示：
#include <sys/times.h>
clock_t times(struct tms *buf);
使用该函数需要包含头文件<sys/times.h>。
函数参数和返回值含义如下：
buf： times()会将当前进程时间信息存在一个 struct tms 结构体数据中，所以我们需要提供 struct tms 变量，使用参数 buf 指向该变量 

返回值： 返回值类型为 clock_t（实质是 long 类型）， 调用成功情况下，将返回从过去任意的一个时间
点（譬如系统启动时间）所经过的时钟滴答数（其实就是系统节拍数）， 将(节拍数 / 节拍率)便可得到秒数，返回值可能会超过 clock_t 所能表示的范围（溢出）； 调用失败返回-1，并设置 errno。 

struct tms 结构体内容如下所示： 

```
struct tms {
    clock_t tms_utime; /* user time, 进程的用户 CPU 时间, tms_utime 个系统节拍数 */
    clock_t tms_stime; /* system time, 进程的系统 CPU 时间, tms_stime 个系统节拍数 */
    clock_t tms_cutime; /* user time of children, 已死掉子进程的 tms_utime + tms_cutime 时间总和 */
	clock_t tms_cstime; /* system time of children, 已死掉子进程的 tms_stime + tms_cstime 时间总和 */
};
```



#### 7.3.2 clock 函数 

库函数 clock()提供了一个更为简单的方式用于进程时间，它的返回值描述了进程使用的总的 CPU 时间
（也就是进程时间，包括用户 CPU 时间和系统 CPU 时间） 

clock_t clock(void);
使用该函数需要包含头文件<time.h>。
函数参数和返回值含义如下：
无参数。
返回值： 返回值是到目前为止程序的进程时间，为 clock_t 类型，注意 clock()的返回值并不是系统节拍
数，如果想要获得秒数，请除以 CLOCKS_PER_SEC（这是一个宏）。 如果返回的进程时间不可用或其值无法表示，则该返回值是-1。
clock()函数虽然可以很方便的获取总的进程时间，但并不能获取到单独的用户 CPU 时间和系统 CPU 时
间，在实际编程当中，根据自己的需要选择 

### 7.4 产生随机数 

**随机数与伪随机数** 

随机数是随机出现，没有任何规律的一组数列。在我们编程当中，是没有办法获得真正意义上的随机数
列的， 这是一种理想的情况，在我们的程序当中想要使用随机数列，只能通过算法得到一个伪随机数序列，那在编程当中说到的随机数，基本都是指伪随机数。
C 语言函数库中提供了很多函数用于产生伪随机数，其中最常用的是通过 rand()和 srand()产生随机数，
本小节就以这两个函数为例向大家介绍如何在我们的程序中获得随机数列 

**rand 函数**
rand()函数用于获取随机数，多次调用 rand()可得到一组随机数序列， 

int rand(void);
使用该函数需要包含头文件<stdlib.h>。
函数参数和返回值含义如下：
返回值： 返回一个介于 0 到 RAND_MAX（包含）之间的值，也就是数学上的[0, RAND_MAX]。

程度当中调用 rand()可以得到[0, RAND_MAX]之间的伪随机数，多次调用 rand()便可以生成一组伪随机
树序列，但是这里有个问题，就是每一次运行程序所得到的随机数序列都是相同的，那如何使得每一次启动应用程序所得到的随机数序列是不一样的呢？那就通过设置不同的随机数种子，可通过 srand()设置随机数种子。
如果没有调用 srand()设置随机数种子的情况下， rand()会将 1 作为随机数种子，如果随机数种子相同，
那么每一次启动应用程序所得到的随机数序列就是一样的，所以每次启动应用程序需要设置不同的随机数种子，这样就可以使得程序每次运行所得到随机数序列不同。 

**srand 函数** 

使用 srand()函数为 rand()设置随机数种子， 

void srand(unsigned int seed);
函数参数和返回值含义如下：
seed： 指定一个随机数中， int 类型的数据，一般尝尝将当前时间作为随机数种子赋值给参数 seed，譬
如 time(NULL)，因为每次启动应用程序时间上是一样的，所以就能够使得程序中设置的随机数种子在每次启动程序时是不一样的。
返回值： void
常用的用法 srand(time(NULL)); 

测试
使用 rand()和 srand()产生一组伪随机数，数值范围为[0~100]，将其打印出来 ：

```
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int main(int argc, char *argv[])
{
    int random_number_arr[8];
    int count;
    /* 设置随机数种子 */
    srand(time(NULL));
    /* 生成伪随机数 */
    for (count = 0; count < 8; count++)
    	random_number_arr[count] = rand() % 100;
    /* 打印随机数数组 */
    printf("[");
    for (count = 0; count < 8; count++) {
        printf("%d", random_number_arr[count]);
    if (count != 8 - 1)
    	printf(", ");
    }
    printf("]\n");
    exit(0);
}
```



### 7.5 休眠 

有时需要将进程暂停或休眠一段时间， 进入休眠状态之后，程序将暂停运行，直到休眠结束。 常用的系
统调用和 C 库函数有 sleep()、 usleep()以及 nanosleep()， 

#### 7.5.1 秒级休眠: sleep 

sleep()是一个 C 库函数，从函数名字面意思便可以知道该函数的作用了，简单地说， sleep()就是让程序
“休息”一会，然后再继续工作。 

unsigned int sleep(unsigned int seconds);
使用该函数需要包含头文件<unistd.h>。
函数参数和返回值含义如下：
seconds： 休眠时长，以秒为单位。
返回值： 如果休眠时长为参数 seconds 所指定的秒数，则返回 0；若被信号中断则返回剩余的秒数。
sleep()是一个秒级别休眠函数，程序在休眠过程中，是可以被其它信号所打断的

#### 7.5.2 微秒级休眠: usleep  

usleep()同样也是一个 C 库函数，与 sleep()的区别在于休眠时长精度不同，usleep()支持微秒级程序休眠， 

int usleep(useconds_t usec);
函数参数和返回值含义如下：
usec： 休眠时长，以微秒为单位。
返回值： 成功返回 0；失败返回-1，并设置 errno。 

#### 7.5.3 高精度休眠: nanosleep 

nanosleep()与 sleep()以及 usleep()类似，都用于程序休眠，但 nanosleep()具有更高精度来设置休眠时间长度，支持纳秒级时长设置。与 sleep()、 usleep()不同的是， nanosleep()是一个 Linux 系统调用， 

int nanosleep(const struct timespec *req, struct timespec *rem);
使用该函数需要包含头文件<time.h>。
函数参数与返回值含义如下：
req： 一个 struct timespec 结构体指针，指向一个 struct timespec 变量，用于设置休眠时间长度，可精确
到纳秒级别。
rem： 也是一个 struct timespec 结构体指针，指向一个 struct timespec 变量，也可设置 NULL。
返回值： 在成功休眠达到请求的时间间隔后， nanosleep()返回 0； 如果中途被信号中断或遇到错误，则返回-1， 并将剩余时间记录在参数 rem 指向的 struct timespec 结构体变量中（参数 rem 不为 NULL 的情况下，如果为 NULL 表示不接收剩余时间），还会设置 errno 标识错误类型。 

### 7.6 申请堆内存 

在操作系统下，内存资源是由操作系统进行管理、分配的，当应用程序想要内存时（这里指的是堆内
存），可以向操作系统申请内存，然后使用内存；当不再需要时，将申请的内存释放、归还给操作系统； 在许多的应用程序当中，往往都会有这种需求，譬如为一些数据结构动态分配/释放内存空间， 本小节向大家介绍应用程序如何向操作系统申请堆内存。 

#### 7.6.1 在堆上分配内存： malloc 和 free 

Linux C 程序当中一般使用 malloc()函数为程序分配一段堆内存，而使用 free()函数来释放这段内存 

**malloc()函数** 

void *malloc(size_t size);
使用该函数需要包含头文件<stdlib.h>。
函数参数和返回值含义如下：
size： 需要分配的内存大小，以字节为单位。 

返回值： 返回值为 void *类型，如果申请分配内存成功，将返回一个指向该段内存的指针， void *并不
是说没有返回值或者返回空指针，而是返回的指针类型未知,所以在调用 malloc()时通常需要进行强制类型转换，将 void *指针类型转换成我们希望的类型；如果分配内存失败（譬如系统堆内存不足）将返回 NULL，如果参数 size 为 0，返回值也是 NULL。 

malloc()在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被
初始化，它们的值是未知的，所以通常需要程序员对 malloc()分配的堆内存进行初始化操作。
在堆上分配的内存，需要开发者自己手动释放掉，通常使用 free()函数释放堆内存 

**free()函数** 

void free(void *ptr);
使用该函数同样需要包含头文件<stdlib.h>。
函数参数和返回值含义如下：
ptr： 指向需要被释放的堆内存对应的指针。
返回值： 无返回值。 

**调用 free()还是不调用 free()** 

在学习文件 IO 基础章节内容时曾向大家介绍过， Linux 系统中，当一个进程终止时，内核会自动关闭
它没有关闭的所有文件（该进程打开的文件，但是在进程终止时未调用 close()关闭它）。同样，对于内存来
说，也是如此！当进程终止时，内核会将其占用的所有内存都返还给操作系统，这包括在堆内存中由 malloc()函数所分配的内存空间。基于内存的这一自动释放机制，很多应用程序通常会省略对 free()函数的调用。
这在程序中分配了多块内存的情况下可能会特别有用，因为加入多次对 free()的调用不但会消耗品大量
的 CPU 时间，而且可能会使代码趋于复杂。
虽然依靠终止进程来自动释放内存对大多数程序来说是可以接受的，但最好能够在程序中显式调用
free()释放内存，首先其一，显式调用 free()能使程序具有更好的可读性和可维护性；其二，对于很多程序来说，申请的内存并不是在程序的生命周期中一直需要，大多数情况下，都是根据代码需求动态申请、释放的，如果申请的内存对程序来说已经不再需要了，那么就已经把它释放、归还给操作系统，如果持续占用，将会导致内存泄漏，也就是人们常说的“你的程序在吃内存”！ 

**用 calloc()分配内存** 3

calloc()函数用来动态地分配内存空间并初始化为 0， 

#### 7.6.2 分配对其内存 

C 函数库中还提供了一系列在堆上分配对齐内存的函数，对齐内存在某些应用场合非常有必要，常用于
分配对其内存的库函数有： posix_memalign()、 aligned_alloc()、 memalign()、 valloc()、 pvalloc()， 

### 7.7 proc 文件系统 



## 8.信号： 基础 

本章将讨论信号，虽然信号的基本概念比较简单，但是其所涉及到的细节内容比较多，所以本章篇幅也
会相对比较长。 事实上，在很多应用程序当中，都会存在处理异步事件这种需求，而信号提供了一种处理异步事件的方法，所以信号机制在 Linux 早期版本中就已经提供了支持，随着 Linux 内核版本的更新迭代，其对信号机制的支持更加完善。
本章将会讨论如下主题内容。
⚫ 信号的基本概念；
⚫ 信号的分类、 Linux 提供的各种不同的信号及其作用；
⚫ 发出信号以及响应信号，信号由“谁”发送、由“谁”处理以及如何处理；
⚫ 进程在默认情况下对信号的响应方式；
⚫ 使用进程信号掩码来阻塞信号、以及等待信号等相关概念；
⚫ 如何暂停进程的执行，并等待信号的到达。 

### 8.1 基本概念 

信号是事件发生时对进程的通知机制，也可以把它称为软件中断。信号与硬件中断的相似之处在于能够
打断程序当前执行的正常流程， 其实是在软件层次上对中断机制的一种模拟。 大多数情况下，是无法预测信号达到的准确时间，所以，信号提供了一种处理异步事件的方法。 

**信号的目的是用来通信的** 

**信号由谁处理、怎么处理** 

信号通常是发送给对应的进程，当信号到达后， 该进程需要做出相应的处理措施，通常进程会视具体信
号执行以下操作之一： 

⚫ 忽略信号。也就是说，当信号到达进程后，该进程并不会去理会它、直接忽略，就好像是没有出该
信号，信号对该进程不会产生任何影响。事实上，大多数信号都可以使用这种方式进行处理，但有
两种信号却决不能被忽略，它们是 SIGKILL 和 SIGSTOP，这两种信号不能被忽略的原因是：它们
向内核和超级用户提供了使进程终止或停止的可靠方法。另外，如果忽略某些由硬件异常产生的信
号，则进程的运行行为是未定义的。
⚫ 捕获信号。 当信号到达进程后，执行预先绑定好的信号处理函数。为了做到这一点，要通知内核在
某种信号发生时，执行用户自定义的处理函数，该处理函数中将会对该信号事件作出相应的处理，
Linux 系统提供了 signal()系统调用可用于注册信号的处理函数，将会在后面向大家介绍。
⚫ 执行系统默认操作。 进程不对该信号事件作出处理，而是交由系统进行处理，每一种信号都会有其
对应的系统默认的处理方式， 8.3 小节中对此有进行介绍。需要注意的是，对大多数信号来说，系
统默认的处理方式就是终止该进程。 

**信号是异步的** 

信号是异步事件的经典实例，产生信号的事件对进程而言是随机出现的，进程无法预测该事件产生的准
确时间，进程不能够通过简单地测试一个变量或使用系统调用来判断是否产生了一个信号，这就如同硬件中断事件，程序是无法得知中断事件产生的具体时间，只有当产生中断事件时，才会告知程序、然后打断当前程序的正常执行流程、跳转去执行中断服务函数，这就是异步处理方式。 

**信号本质上是 int 类型数字编号** 

信号本质上是 int 类型的数字编号，这就好比硬件中断所对应的中断号。内核针对每个信号，都给其定
义了一个唯一的整数编号，从数字 1 开始顺序展开。并且每一个信号都有其对应的名字（其实就是一个宏），信号名字与信号编号乃是一一对应关系，但是由于每个信号的实际编号随着系统的不同可能会不一样，所以在程序当中一般都使用信号的符号名（也就是宏定义）。 

这些信号在<signum.h>头文件中定义， 每个信号都是以 SIGxxx 开头， 如下所示： 

```
/* Signals. */
#define SIGHUP 1 /* Hangup (POSIX). */
#define SIGINT 2 /* Interrupt (ANSI). */
#define SIGQUIT 3 /* Quit (POSIX). */
#define SIGILL 4 /* Illegal instruction (ANSI). */
#define SIGTRAP 5 /* Trace trap (POSIX). */
#define SIGABRT 6 /* Abort (ANSI). */
#define SIGIOT 6 /* IOT trap (4.2 BSD). */
#define SIGBUS 7 /* BUS error (4.2 BSD). */
#define SIGFPE 8 /* Floating-point exception (ANSI). */
#define SIGKILL 9 /* Kill, unblockable (POSIX). */
#define SIGUSR1 10 /* User-defined signal 1 (POSIX). */
#define SIGSEGV 11 /* Segmentation violation (ANSI). */
#define SIGUSR2 12 /* User-defined signal 2 (POSIX). */
#define SIGPIPE 13 /* Broken pipe (POSIX). */
#define SIGALRM 14 /* Alarm clock (POSIX). */
#define SIGTERM 15 /* Termination (ANSI). */
#define SIGSTKFLT 16 /* Stack fault. */
#define SIGCLD SIGCHLD /* Same as SIGCHLD (System V). */
#define SIGCHLD 17 /* Child status has changed (POSIX). */
#define SIGCONT 18 /* Continue (POSIX). */
#define SIGSTOP 19 /* Stop, unblockable (POSIX). */
#define SIGTSTP 20 /* Keyboard stop (POSIX). */
#define SIGTTIN 21 /* Background read from tty (POSIX). */
#define SIGTTOU 22 /* Background write to tty (POSIX). */
#define SIGURG 23 /* Urgent condition on socket (4.2 BSD). */
#define SIGXCPU 24 /* CPU limit exceeded (4.2 BSD). */
#define SIGXFSZ 25 /* File size limit exceeded (4.2 BSD). */
#define SIGVTALRM 26 /* Virtual alarm clock (4.2 BSD). */
#define SIGPROF 27 /* Profiling alarm clock (4.2 BSD). */
#define SIGWINCH 28 /* Window size change (4.3 BSD, Sun). */
#define SIGPOLL SIGIO /* Pollable event occurred (System V). */
#define SIGIO 29 /* I/O now possible (4.2 BSD). */
#define SIGPWR 30 /* Power failure restart (System V). */
#define SIGSYS 31 /* Bad system call. */
#define SIGUNUSED 31
```

不存在编号为 0 的信号，从示例代码 8.1.1 中也可以看到，信号编号是从 1 开始的，事实上 kill()函数
对信号编号 0 有着特殊的应用，关于这个文件将会在后面的内容向大家介绍。 

### 8.2 信号的分类 

Linux 系统下可对信号从两个不同的角度进行分类，从可靠性方面将信号分为可靠信号与不可靠信号；
而从实时性方面将信号分为实时信号与非实时信号，本小节将对这些信号的分类进行简单地介绍。 

#### 8.2.1 可靠信号与不可靠信号 

Linux 信号机制基本上是从 UNIX 系统中继承过来的， 早期 UNIX 系统中的信号机制比较简单和原始，
后来在实践中暴露出一些问题，它的主要问题是： 

⚫ 进程每次处理信号后，就将对信号的响应设置为系统默认操作。在某些情况下，将导致对信号的错
误处理；因此，用户如果不希望这样的操作，那么就要在信号处理函数结尾再一次调用 signal()，
重新为该信号绑定相应的处理函数。
⚫ 因此导致， 早期 UNIX 下的不可靠信号主要指的是进程可能对信号做出错误的反应以及信号可能
丢失（处理信号时又来了新的信号，则导致信号丢失）。 

Linux 支持不可靠信号，但是对不可靠信号机制做了改进： 在调用完信号处理函数后，不必重新调用
signal()。因此，Linux 下的不可靠信号问题主要指的是信号可能丢失。在 Linux 系统下，信号值小于 SIGRTMIN（34） 的信号都是不可靠信号， 这就是"不可靠信号"的来源，所以示例代码 8.1.1 中所列举的信号都是不可靠信号 。

Linux 系统下使用"kill -l"命令可查看到所有信号

Tips：括号" ) "前面的数字对应该信号的编号，编号 1~31 所对应的是不可靠信号，编号 34~64 对应的是
可靠信号，从图中可知，可靠信号并没有一个具体对应的名字，而是使用了 SIGRTMIN+N 或者SIGRTMAXN 的方式来表示。 

靠信号支持排队，不会丢失， 同时，信号的发送和绑定也出现了新版本， 信号发送函数 sigqueue()及
信号绑定函数 sigaction() 

#### 8.2.2 实时信号与非实时信号 

实时信号与非实时信号其实是从时间关系上进行的分类，与可靠信号与不可靠信号是相互对应的， 非实
时信号都不支持排队，都是不可靠信号；实时信号都支持排队，都是可靠信号。 实时信号保证了发送的多个信号都能被接收， 实时信号是 POSIX 标准的一部分，可用于应用进程。
一般我们也把非实时信号（不可靠信号）称为标准信号，如果文档中用到了这个词，那么大家要知道，
这里指的就是非实时信号（不可靠信号）。 

### 8.3 常见信号与默认行为 

前面说到， Linux 下对标准信号（不可靠信号、 非实时信号） 的编号为 1~31，如示例代码 8.1.1 所示，接下来将介绍这些信号以及这些信号所对应的系统默认操作。 

⚫ SIGINT
当用户在终端按下中断字符（通常是 CTRL + C）时，内核将发送 SIGINT 信号给前台进程组中的每一
个进程。该信号的系统默认操作是终止进程的运行。 所以通常我们都会使用 CTRL + C 来终止一个占用前台
的进程，原因在于大部分的进程会将该信号交给系统去处理，从而执行该信号的系统默认操作。
⚫ SIGQUIT
当用户在终端按下退出字符（通常是 CTRL + \）时，内核将发送 SIGQUIT 信号给前台进程组中的每一
个进程。该信号的系统默认操作是终止进程的运行、并生成可用于调试的核心转储文件。 进程如果陷入无限
循环、或不再响应时，使用 SIGQUIT 信号就很合适。所以对于一个前台进程，既可以在终端按下中断字符
CTRL + C、也可以按下退出字符 CTRL + \来终止，当然前提条件是，此进程会将 SIGINT 信号或 SIGQUIT
信号交给系统处理（也就是没有将信号忽略或捕获） ，进入执行该信号所对应的系统默认操作。
⚫ SIGILL
如果进程试图执行非法（即格式不正确）的机器语言指令，系统将向进程发送该信号。该信号的系统默
认操作是终止进程的运行。
⚫ SIGABRT
当进程调用 abort()系统调用时（进程异常终止） ，系统会向该进程发送 SIGABRT 信号。该信号的系统
默认操作是终止进程、并生成核心转储文件。
⚫ SIGBUS
产生该信号（总线错误， bus error）表示发生了某种内存访问错误。该信号的系统默认操作是终止进程。
⚫ SIGFPE
该信号因特定类型的算术错误而产生，譬如除以 0。该信号的系统默认操作是终止进程。
⚫ SIGKILL
此信号为“必杀（sure kill）”信号，用于杀死进程的终极办法，此信号无法被进程阻塞、忽略或者捕
获，故而“一击必杀”，总能终止进程。 使用 SIGINT 信号和 SIGQUIT 信号虽然能终止进程，但是前提条
件是该进程并没有忽略或捕获这些信号，如果使用 SIGINT 或 SIGQUIT 无法终止进程，那就使用“必杀信
号” SIGKILL 吧。 Linux 下有一个 kill 命令， kill 命令可用于向进程发送信号，我们会使用"kill -9 xxx"命令来终止一个进程（xxx 表示进程的 pid），这里的-9 其实指的就是发送编号为 9 的信号，也就是 SIGKILL 信号。 

⚫ SIGUSR1 

该信号和 SIGUSR2 信号供程序员自定义使用，内核绝不会为进程产生这些信号，在我们的程序中，可
以使用这些信号来互通通知事件的发生，或是进程彼此同步操作。 该信号的系统默认操作是终止进程。
⚫ SIGSEGV
这一信号非常常见，当应用程序对内存的引用无效时，操作系统就会向该应用程序发送该信号。引起对
内存无效引用的原因很多， C 语言中引发这些事件往往是解引用的指针里包含了错误地址（譬如，未初始化
的指针），或者传递了一个无效参数供函数调用等。该信号的系统默认操作是终止进程。
⚫ SIGUSR2
与 SIGUSR1 信号相同。
⚫ SIGPIPE
涉及到管道和 socket，当进程向已经关闭的管道、 FIFO 或套接字写入信息时，那么系统将发送该信号
给进程。该信号的系统默认操作是终止进程。
⚫ SIGALRM
与系统调用 alarm()或 setitimer()有关，应用程序中可以调用 alarm()或 setitimer()函数来设置一个定时器，
当定时器定时时间到，那么内核将会发送 SIGALRM 信号给该应用程序，关于 alarm()或 setitimer()函数的使
用，后面将会进行讲解。该信号的系统默认操作是终止进程。
⚫ SIGTERM
这是用于终止进程的标准信号，也是 kill 命令所发送的默认信号（kill xxx， xxx 表示进程 pid） ，有时
我们会直接使用"kill -9 xxx"显式向进程发送 SIGKILL 信号来终止进程，然而这一做法通常是错误的，精心
设计的应用程序应该会捕获 SIGTERM 信号、并为其绑定一个处理函数，当该进程收到 SIGTERM 信号时，
会在处理函数中清除临时文件以及释放其它资源，再而退出程序。如果直接使用 SIGKILL 信号终止进程，
从而跳过了 SIGTERM 信号的处理函数，通常 SIGKILL 终止进程是不友好的方式、是暴力的方式，这种方
式应该作为最后手段，应首先尝试使用 SIGTERM，实在不行再使用最后手段 SIGKILL。
⚫ SIGCHLD
当父进程的某一个子进程终止时，内核会向父进程发送该信号。当父进程的某一个子进程因收到信号而
停止或恢复时，内核也可能向父进程发送该信号。 注意这里说的停止并不是终止，你可以理解为暂停。 该信
号的系统默认操作是忽略此信号，如果父进程希望被告知其子进程的这种状态改变，则应捕获此信号。
⚫ SIGCLD
与 SIGCHLD 信号同义。
⚫ SIGCONT
将该信号发送给已停止的进程，进程将会恢复运行。当进程接收到此信号时并不处于停止状态， 系统默
认操作是忽略该信号，但如果进程处于停止状态，则系统默认操作是使该进程继续运行。
⚫ SIGSTOP
这是一个“必停”信号，用于停止进程（注意停止不是终止，停止只是暂停运行、进程并没有终止），
应用程序无法将该信号忽略或者捕获，故而总能停止进程。
⚫ SIGTSTP
这也是一个停止信号，当用户在终端按下停止字符（通常是 CTRL + Z），那么系统会将 SIGTSTP 信号
发送给前台进程组中的每一个进程，使其停止运行。
⚫ SIGXCPU
当进程的 CPU 时间超出对应的资源限制时，内核将发送此信号给该进程。
⚫ SIGVTALRM
应用程序调用 setitimer()函数设置一个虚拟定时器，当定时器定时时间到时，内核将会发送该信号给进
程。
⚫ SIGWINCH 

在窗口环境中，当终端窗口尺寸发生变化时（譬如用户手动调整了大小，应用程序调用 ioctl()设置了大
小等），系统会向前台进程组中的每一个进程发送该信号。
⚫ SIGPOLL/SIGIO
这两个信号同义。这两个信号将会在高级 IO 章节内容中使用到，用于提示一个异步 IO 事件的发生，
譬如应用程序打开的文件描述符发生了 I/O 事件时，内核会向应用程序发送 SIGIO 信号。
⚫ SIGSYS
如果进程发起的系统调用有误，那么内核将发送该信号给对应的进程。 

### 8.4 进程对信号的处理 

当进程接收到内核或用户发送过来的信号之后，根据具体信号可以采取不同的处理方式：忽略信号、捕
获信号或者执行系统默认操作。 Linux 系统提供了系统调用 signal()和 sigaction()两个函数用于设置信号的处理方式，本小节将向大家介绍这两个系统调用的使用方法。 

#### 8.4.1 signal()函数 

本节描述系统调用 signal()， signal()函数是 Linux 系统下设置信号处理方式最简单的接口， 可将信号的
处理方式设置为捕获信号、 忽略信号以及系统默认操作 ，此函数原型如下所示 ：

typedef void (*sig_t)(int);
sig_t signal(int signum, sig_t handler);
使用该函数需要包含头文件<signal.h>。
函数参数和返回值含义如下：
signum： 此参数指定需要进行设置的信号，可使用信号名（宏）或信号的数字编号，建议使用信号名。
handler： sig_t 类型的函数指针，指向信号对应的信号处理函数，当进程接收到信号后会自动执行该处
理函数；参数 handler 既可以设置为用户自定义的函数，也就是捕获信号时需要执行的处理函数，也可以设置为 SIG_IGN 或 SIG_DFL， SIG_IGN 表示此进程需要忽略该信号， SIG_DFL 则表示设置为系统默认操作。
sig_t 函数指针的 int 类型参数指的是，当前触发该函数的信号，可将多个信号绑定到同一个信号处理函数上，此时就可通过此参数来判断当前触发的是哪个信号。 

**Tips： SIG_IGN、 SIG_DFL 分别取值如下：
/* Fake signal functions. */
#define SIG_ERR ((sig_t) -1) /* Error return. */
#define SIG_DFL ((sig_t) 0) /* Default action. */
#define SIG_IGN ((sig_t) 1) /* Ignore signal. */** 

返回值： 此函数的返回值也是一个 sig_t 类型的函数指针，成功情况下的返回值则是指向在此之前的信
号处理函数；如果出错则返回 SIG_ERR，并会设置 errno。 

两种不同状态下信号的处理方式
通过上面的介绍， 以及我们的测试实验， 不知大家是否出现了一个疑问？如果程序中没有调用 signal()
函数为信号设置相应的处理方式，亦或者程序刚启动起来并未运行到 signal()处，那么这时进程接收到一个信号后是如何处理的呢？带着这个问题来聊一聊。 

⚫ 程序启动
当一个应用程序刚启动的时候（或者程序中没有调用 signal()函数） ， 通常情况下， 进程对所有信号的
处理方式都设置为系统默认操作。所以如果在我们的程序当中，没有调用 signal()为信号设置处理方式，则默认的处理方式便是系统默认操作。
所以为什么大家平时都可以使用 CTRL + C 中断符来终止一个进程，因为大部分情况下，应用程序中并
不会为 SIGINT 信号设置处理方式，所以该信号的处理方式便是系统默认操作，当接收到信号之后便执行系统默认操作，而 SIGINT 信号的系统默认操作便是终止进程。 

⚫ 进程创建
当一个进程调用 fork()创建子进程时，其子进程将会继承父进程的信号处理方式，因为子进程在开始时
复制了父进程的内存映像，所以信号捕获函数的地址在子进程中是有意义的。 

#### 8.4.2 sigaction()函数 

除了 signal()之外，sigaction()系统调用是设置信号处理方式的另一选择，事实上，推荐大家使用 sigaction()函数。虽然 signal()函数简单好用，而 sigaction()更为复杂，但作为回报， sigaction()也更具灵活性以及移植性。
sigaction()允许单独获取信号的处理函数而不是设置，并且还可以设置各种属性对调用信号处理函数时
的行为施以更加精准的控制，其函数原型如下所示： 

int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
使用该函数需要包含头文件<signal.h>。
函数参数和返回值含义如下：
​	signum： 需要设置的信号，除了 **SIGKILL** 信号和 **SIGSTOP** 信号之外的任何信号。
​	act： act 参数是一个 struct sigaction 类型指针，指向一个 struct sigaction 数据结构，该数据结构描述了信号的处理方式，稍后介绍该数据结构；如果参数 act 不为 NULL，则表示需要为信号设置新的处理方式；如果参数 act 为 NULL，则表示无需改变信号当前的处理方式。
​	oldact： oldact 参数也是一个 struct sigaction 类型指针，指向一个 struct sigaction 数据结构。如果参数oldact 不为 NULL， 则会将信号之前的处理方式等信息通过参数 oldact 返回出来；如果无意获取此类信息，那么可将该参数设置为 NULL。
​	返回值： 成功返回 0；失败将返回-1，并设置 errno。 

struct sigaction 结构体 

```
struct sigaction {
	void (*sa_handler)(int);
	void (*sa_sigaction)(int, siginfo_t *, void *);
	sigset_t sa_mask;
    int sa_flags;
	void (*sa_restorer)(void);
};
```

结构体成员介绍：
⚫ sa_handler：指定信号处理函数，与 signal()函数的 handler 参数相同。
⚫ sa_sigaction：也用于指定信号处理函数，这是一个替代的信号处理函数，他提供了更多的参数，可以通过该函数获取到更多信息，这些信号通过 siginfo_t 参数获取，稍后介绍该数据结构； sa_handler 和sa_sigaction 是互斥的，不能同时设置， 对于标准信号来说， 使用 sa_handler 就可以了，可通过
SA_SIGINFO 标志进行选择。
⚫ sa_mask： 参数 sa_mask 定义了一组信号， 当进程在执行由 sa_handler 所定义的信号处理函数之前，会先将这组信号添加到进程的信号掩码字段中，当进程执行完处理函数之后再恢复信号掩码，将这组信号从信号掩码字段中删除。 当进程在执行信号处理函数期间， 可能又收到了同样的信号或其它信号，从而打断当前信号处理函数的执行，这就好点像中断嵌套；通常我们在执行信号处理函数期间不希望被另一个信号所打断，那么怎么做呢？那么就是通过信号掩码来实现， 如果进程接收到了信号掩码中的这些信号，那么这个信号将会被阻塞暂时不能得到处理，直到这些信号从进程的信号掩码中移除。 在信号处理函数调用时，进程会自动将当前处理的信号添加到信号掩码字段中，这样保证了在处理一个给定的信号时，如果此信号再次发生，那么它将会被阻塞。如果用户还需要在阻塞其它的信号，则可以通过设置参 数 sa_mask 来完成（此参数是 sigset_t 类型变量，关于该类型的介绍信息请看 8.6.1 小节内容，关于信号掩码还会在 8.7.1 小节中进一步介绍），信号掩码可以避免一些信号之间的竞争状态（也称为竞态）。 

⚫ sa_restorer：该成员已过时，不要再使用了。
⚫ sa_flags： 参数 sa_flags 指定了一组标志，这些标志用于控制信号的处理过程，可设置为如下这些标志
（多个标志使用位或" | "组合）：
SA_NOCLDSTOP
如果 signum为 SIGCHLD，则子进程停止时（即当它们接收到 SIGSTOP、SIGTSTP、SIGTTIN 或 SIGTTOU
中的一种时）或恢复（即它们接收到 SIGCONT）时不会收到 SIGCHLD 信号。
SA_NOCLDWAIT
如果 signum 是 SIGCHLD，则在子进程终止时不要将其转变为僵尸进程。
SA_NODEFER
不要阻塞从某个信号自身的信号处理函数中接收此信号。 也就是说当进程此时正在执行某个信号的处
理函数，默认情况下，进程会自动将该信号添加到进程的信号掩码字段中，从而在执行信号处理函数期间阻塞该信号， 默认情况下，我们期望进程在处理一个信号时阻塞同种信号，否则引起一些竞态条件；如果设置了 SA_NODEFER 标志，则表示不对它进行阻塞。
SA_RESETHAND
执行完信号处理函数之后，将信号的处理方式设置为系统默认操作。
SA_RESTART
被信号中断的系统调用，在信号处理完成之后将自动重新发起。
SA_SIGINFO
如果设置了该标志，则表示使用 sa_sigaction 作为信号处理函数、而不是 sa_handler，关于 sa_sigaction信号处理函数的参数信息。
